<html>
<head>
<title>FCSys.Subregions.Species</title>
<meta name="HTML-Generator" content="Dymola">
<meta name="description" content="Models for single-species storage, transport, and exchange of material, linear momentum, and energy">
<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="../resources/documentation/ModelicaDoc.css">
<link rel="shortcut icon" href="../resources/documentation/favicon.ico">
</head>
<body>
<div class="sidebar">
  <div class="sidebarwrapper">
  <a href="FCSys.html"><p class="sidebar-title">FCSys</p></a>
  <p class="logo"><a href="FCSys.html">
    <img src="../resources/documentation/icon.gif" class="logo" alt="Logo" width=150>
  </a></p>

<h3>Table of Contents</h3>

<ul>
    <li><a href="FCSys_UsersGuide.html">User's Guide</a></li>
    <li><a href="FCSys_Blocks.html">Blocks</a></li>
    <li><a href="FCSys_Conditions.html">Conditions</a></li>
    <li><a href="FCSys_Assemblies.html">Assemblies</a></li>
    <li><a href="FCSys_Regions.html">Regions</a></li>
    <li><a href="FCSys_Subregions.html">Subregions</a></li>
    <li><a href="FCSys_Connectors.html">Connectors</a></li>
    <li><a href="FCSys_Characteristics.html">Characteristics</a></li>
    <li><a href="FCSys_Units.html">Units</a></li>
    <li><a href="FCSys_Quantities.html">Quantities</a></li>
    <li><a href="FCSys_BaseClasses.html">BaseClasses</a></li>
    </ul>
  </div>
</div>

<div class="document">
  <div class="documentwrapper">
    <div class="bodywrapper">
      <div class="body">

<h2><a name="FCSys.Subregions.Species"></a><a href="FCSys_Subregions.html#FCSys.Subregions">FCSys.Subregions</a>.Species</h2>

<b>Models for single-species storage, transport, and exchange of material, linear momentum, and energy</b>

<h3>Information</h3>

Extends from <a href="http://build.openmodelica.org/Documentation/Modelica.Icons.Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).

<h3>Package Content</h3>

<table border=1 cellspacing=0 cellpadding=2 >
<tr><th>Name</th><th>Description</th></tr>
<tr><td><img src="FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'C+'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'C+'.html#FCSys.Subregions.Species.'C+'">'C+'</a>
</td><td>C</td></tr>
<tr><td><img src="FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'C19HF37O5S-'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'C19HF37O5S-'.html#FCSys.Subregions.Species.'C19HF37O5S-'">'C19HF37O5S-'</a>
</td><td>C<sub>19</sub>HF<sub>37</sub>O<sub>5</sub>S<sup>-</sup></td></tr>
<tr><td><img src="FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'e-'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'e-'.html#FCSys.Subregions.Species.'e-'">'e-'</a>
</td><td>e<sup>-</sup></td></tr>
<tr><td><img src="FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'H+'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'H+'.html#FCSys.Subregions.Species.'H+'">'H+'</a>
</td><td>H<sup>+</sup></td></tr>
<tr><td><img src="FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.H2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_H2.html#FCSys.Subregions.Species.H2">H2</a>
</td><td>H<sub>2</sub></td></tr>
<tr><td><img src="FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.H2O" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_H2O.html#FCSys.Subregions.Species.H2O">H2O</a>
</td><td>H<sub>2</sub>O</td></tr>
<tr><td><img src="FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.N2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_N2.html#FCSys.Subregions.Species.N2">N2</a>
</td><td>N<sub>2</sub></td></tr>
<tr><td><img src="FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.O2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_O2.html#FCSys.Subregions.Species.O2">O2</a>
</td><td>O<sub>2</sub></td></tr>
<tr><td><img src="FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.SpeciesSolid" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesSolid">SpeciesSolid</a>
</td><td>Solid species (inert and stagnant)</td></tr>
<tr><td><img src="FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.SpeciesIncompressible" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIncompressible">SpeciesIncompressible</a>
</td><td>Incompressible species</td></tr>
<tr><td><img src="FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.Species" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a>
</td><td>Model for single-species exchange, transport, and storage of material, linear momentum, and energy</td></tr>
<tr><td><img src="FCSys.Subregions.Species.BaseClassesS.png" alt="FCSys.Subregions.Species.BaseClasses" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses">BaseClasses</a>
</td><td>Base classes (not generally for direct use)</td></tr>
</table>
<hr>

<h2><img src="FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.SpeciesSolid" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.SpeciesSolid"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.SpeciesSolid</h2>
<b>Solid species (inert and stagnant)</b><p>
<img src="FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.SpeciesSolid">

<h3>Information</h3>

<p>Assumptions:<ol>
  <li>Zero dynamic compressibility (&rArr; uniform current)</li>
  <li>Zero dynamic fluidity (&rArr; no shearing)</li></ol></p>

  <p>Usually, conditions should be applied to specify the velocity (typically <b>0</b>).  In a group of connected solid species
  of a single type (instances of a model derived from this one), there should be exactly one equation to specify the velocity along each Cartesian axis.
  For example, the x-axis velocity may be given by setting <code>setVelX</code> to <code>true</code> in one of the instances
  (x-axis velocity will be <code>phi_IC[Axis.x]</code> for all time).  Alternatively, one of the faces on the outside of the
  group could be removed by setting the appropriate <code>inclFaceNegX</code>, <code>inclFacePosX</code>, etc. parameter
  to <code>false</code>, which will set the current and transverse components of velocity to zero.</p>

  <p>For more information, see the <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model.</p><p>
Extends from <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIncompressible">SpeciesIncompressible</a> (Incompressible species).
<p>

<h3>Parameters</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>Lstar</td><td>&nbsp;</td><td>Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>) [l]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td>Characteristics.BaseClasses&hellip;.</td><td>Characteristic data</td></tr>
<tr><td>Boolean</td><td>inverseEOS</td><td>false</td><td>Use inverse equation of state</td></tr>
<tr><td>Real</td><td>Xi</td><td>Data.alpha(T)*p</td><td>**Dynamic compressibility (&Xi;)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CompressibilityDynamic">CompressibilityDynamic</a></td><td>x</td><td>Data.Xi(T, p)</td><td>**Dynamic compressibility (&Xi;) [N.T/(l2.m)]</td></tr>
<tr><td>&nbsp;</td><td>F</td><td>Data.F(T, p)</td><td>Dynamic fluidity</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>R</td><td>Data.R(T, p)</td><td>Thermal resistivity</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Prescribed states (via initialization parameters)</td></tr>
<tr><td>Boolean</td><td>setPartNum</td><td>false</td><td>Particle number</td></tr>
<tr><td>Boolean</td><td>setVelX</td><td>false</td><td>X-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelY</td><td>false</td><td>Y-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelZ</td><td>false</td><td>Z-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setTemp</td><td>false</td><td>Temperature</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>false</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>false</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>false</td><td>Z</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Scalar properties</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethPartNum</td><td>InitMethScalar.Volume</td><td>Method of initializing the particle number</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethTemp</td><td>InitMethScalar.Temperature</td><td>Method of initializing the temperature</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>derN_IC</td><td>0</td><td>Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">VolumeSpecific</a></td><td>v_IC</td><td>&nbsp;</td><td>Initial specific volume (<i>v</i><sub>IC</sub>) [l3/N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecificRate">VolumeSpecificRate</a></td><td>derv_IC</td><td>0</td><td>Initial rate of specific volume ((&part;<i>v</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/(N.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">VolumeRate</a></td><td>derV_IC</td><td>0</td><td>Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">PressureRate</a></td><td>derp_IC</td><td>0</td><td>Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>) [m/(l.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">TemperatureRate</a></td><td>derT_IC</td><td>0</td><td>Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>derh_IC</td><td>0</td><td>Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>mu_IC</td><td>&nbsp;</td><td>Initial electrochemical potential (&mu;<sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>dermu_IC</td><td>0</td><td>Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>Ndot_IC</td><td>0</td><td>Initial reaction rate (<i>N&#775;</i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Velocity</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethX</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the x-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethY</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the y-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethZ</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the z-axis component</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>zeros(3)</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
</table>
<p>

<h3>Connectors</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">ChemicalOutput</a></td><td>chemical</td><td>Connector to exchange material while advecting linear momentum and energy</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>common</td><td>Connector to directly couple velocities and temperatures of multiple species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inert</td><td>Connector to exchange linear momentum and heat by diffusion, with additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>faces[Axis, Side]</td><td>Face connectors to transport material, linear momentum, and heat</td></tr>
</table>
<p>

<h3>Modelica definition</h3>

<pre>
<font color="blue">model</font> SpeciesSolid <font color="darkgreen">&quot;Solid species (inert and stagnant)&quot;</font>
  <font color="blue">extends </font><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIncompressible">SpeciesIncompressible</a>(
    <font color="blue">final </font>upstreamX=false,
    <font color="blue">final </font>upstreamY=false,
    <font color="blue">final </font>upstreamZ=false,
    <font color="blue">final </font>Ndot_IC=0,
    <font color="blue">final </font>phi_IC=<font color="red">zeros</font>(3),
    <font color="blue">final </font>derphi_IC,
    <font color="blue">final </font>I_IC,
    <font color="blue">final </font>derI_IC,
    inverseEOS=false);
  <font color="darkgreen">// **final x=0,</font>
  <font color="darkgreen">// **final Xi=0,</font>
  <font color="darkgreen">// **final F=0,</font>
  <font color="darkgreen">// **temp 0.1s instead of 0s</font>

<font color="blue">end </font>SpeciesSolid;
</pre>
<hr>

<h2><img src="FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.SpeciesIncompressible" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.SpeciesIncompressible"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.SpeciesIncompressible</h2>
<b>Incompressible species</b><p>
<img src="FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.SpeciesIncompressible">

<h3>Information</h3>

<p>For more information, see the <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model.</p><p>
Extends from <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> (Model for single-species exchange, transport, and storage of material, linear momentum, and energy).
<p>

<h3>Parameters</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>Lstar</td><td>&nbsp;</td><td>Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>) [l]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td>Characteristics.BaseClasses&hellip;.</td><td>Characteristic data</td></tr>
<tr><td>Boolean</td><td>inverseEOS</td><td>true</td><td>Use inverse equation of state</td></tr>
<tr><td>Real</td><td>Xi</td><td>Data.alpha(T)*p</td><td>**Dynamic compressibility (&Xi;)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CompressibilityDynamic">CompressibilityDynamic</a></td><td>x</td><td>Data.Xi(T, p)</td><td>**Dynamic compressibility (&Xi;) [N.T/(l2.m)]</td></tr>
<tr><td>&nbsp;</td><td>F</td><td>Data.F(T, p)</td><td>Dynamic fluidity</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>R</td><td>Data.R(T, p)</td><td>Thermal resistivity</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Prescribed states (via initialization parameters)</td></tr>
<tr><td>Boolean</td><td>setPartNum</td><td>false</td><td>Particle number</td></tr>
<tr><td>Boolean</td><td>setVelX</td><td>false</td><td>X-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelY</td><td>false</td><td>Y-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelZ</td><td>false</td><td>Z-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setTemp</td><td>false</td><td>Temperature</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Scalar properties</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethPartNum</td><td>InitMethScalar.Volume</td><td>Method of initializing the particle number</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethTemp</td><td>InitMethScalar.Temperature</td><td>Method of initializing the temperature</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>derN_IC</td><td>0</td><td>Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">VolumeSpecific</a></td><td>v_IC</td><td>&nbsp;</td><td>Initial specific volume (<i>v</i><sub>IC</sub>) [l3/N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecificRate">VolumeSpecificRate</a></td><td>derv_IC</td><td>0</td><td>Initial rate of specific volume ((&part;<i>v</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/(N.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">VolumeRate</a></td><td>derV_IC</td><td>0</td><td>Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">PressureRate</a></td><td>derp_IC</td><td>0</td><td>Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>) [m/(l.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">TemperatureRate</a></td><td>derT_IC</td><td>0</td><td>Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>derh_IC</td><td>0</td><td>Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>mu_IC</td><td>&nbsp;</td><td>Initial electrochemical potential (&mu;<sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>dermu_IC</td><td>0</td><td>Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>Ndot_IC</td><td>0</td><td>Initial reaction rate (<i>N&#775;</i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Velocity</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethX</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the x-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethY</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the y-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethZ</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the z-axis component</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>{0,0,0}</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Acceleration">Acceleration</a></td><td>derphi_IC[Axis]</td><td>{0,0,0}</td><td>Initial acceleration ((&part;<b>&phi;</b>/&part;<i>t</i>)<sub>IC</sub>) [l/T2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>I_IC[Axis]</td><td>{0,0,0}</td><td>Initial current (<i><b>I</b></i><sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CurrentRate">CurrentRate</a></td><td>derI_IC[Axis]</td><td>{0,0,0}</td><td>Initial rate of current ((&part;<i><b>I</b></i>/&part;<i>t</i>)<sub>IC</sub>) [N/T2]</td></tr>
</table>
<p>

<h3>Connectors</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">ChemicalOutput</a></td><td>chemical</td><td>Connector to exchange material while advecting linear momentum and energy</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>common</td><td>Connector to directly couple velocities and temperatures of multiple species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inert</td><td>Connector to exchange linear momentum and heat by diffusion, with additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>faces[Axis, Side]</td><td>Face connectors to transport material, linear momentum, and heat</td></tr>
</table>
<p>

<h3>Modelica definition</h3>

<pre>
<font color="blue">model</font> SpeciesIncompressible <font color="darkgreen">&quot;Incompressible species&quot;</font>
  <font color="blue">extends </font><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a>(initMethPartNum=InitMethScalar.Volume);
  <font color="darkgreen">// Note:  The default, pressure, can&#39;t be used to initialize an incompressible</font>
  <font color="darkgreen">// species.</font>

<font color="blue">end </font>SpeciesIncompressible;
</pre>
<hr>

<h2><img src="FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.Species" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.Species"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.Species</h2>
<b>Model for single-species exchange, transport, and storage of material, linear momentum, and energy</b><p>
<img src="FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.Species">

<h3>Information</h3>

<p>This model is based on the following fixed assumptions.  Other assumptions are
    optional via the parameters.
    <ol>
       <li>All faces are rectangular.
       <li>The material is orthorhombic.  This implies that a
          gradient which induces diffusion along an axis does not induce
          diffusion along axes orthogonal to it
          [<a href="FCSys_UsersGuide.html#FCSys.UsersGuide.References">Bejan2006</a>,
          pp. 691&ndash;692].</li>
       <li>The coordinate system (x, y, z) is aligned with the principle
          axes of transport.  For example, if the species is stratified, the
          layers must be parallel to one of the planes in the rectilinear
          grid.</li>
       <li>The factors that may cause anisotropic behavior (<b><i>k</i></b>)
          are common to material, mechanical, and thermal transport.</li>
       <li>There is no radiative heat transfer.</li>
       <li>Angular momentum is not exchanged, transported, or stored.</li>
       <li>For the purpose of the material, linear momentum, and energy balances, the
       cross sectional areas of the faces are assumed to be the full cross-sectional
       areas of the subregion.  If multiple phases are present, then areas are
       actually smaller.</li>
       <li>Relativistic effects are negligible.</li>
    </ol></p>

    <p>Figure 1 shows how instances of
    <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> models (derived from this
    model) are
    connected within a <a href="FCSys_Subregions.html#FCSys.Subregions">Subregion</a>.  The
    generalized resistances (<i>R</i>) affect the flow rates of linear momentum and
    heat associated with differences in velocity and temperature (respectively) between
    each species and a common node.  This exchange is diffusive.

    <p>Linear momentum and enthalpy are advected as material is exchanged in a chemical
    reaction.  This occurs at the velocity and massic enthalpy of the reactants (source
    species), where the reactant/product designation depends on the current conditions.
    If species are connected through
    a <a href="FCSys_Subregions.html#FCSys.Subregions.Reaction">Reaction</a> model, then the material
    states (e.g., amounts of each material) are directly coupled to impose chemical
    equilibrium.
    This reduces the DAE index by one in accordance with Gibbs' phase rule
    [<a href="FCSys_UsersGuide.html#FCSys.UsersGuide.References">Moran2004</a>].
    Resistance is not included directly in the reaction equations;
    the reaction rate is determined solely by
    the transport equations.</p>

    <p align=center><img src="/media/Storage/Dropbox/Documents/Modelica/FCSys/resources/documentation/Subregions/Species/Species/exchange.png">
<br>Figure 1:  Exchange of a quantity (linear momentum or heat) among species
    (A, B, and C) within a subregion.</p>

    <p>Figure 2 shows how <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a>
    instances of the same type are connected between neighboring
    <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a> instances.
    Normal and transverse linear momentum and heat are transported by both advection and diffusion.
    Upstream discretization is applied if it is enabled via the <code>upstreamX</code>,
    etc. parameters.</p>

    <p align=center><img src="/media/Storage/Dropbox/Documents/Modelica/FCSys/resources/documentation/Subregions/Species/Species/transport.png">
<br>Figure 2:  Transport of a quantity associated with the same species
    between subregions (1 and 2).</p>

    <p>All <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> instances
    within a <a href="FCSys_Subregions_Phases.html#FCSys.Subregions.Phases">Phase</a> are joined by Dalton's law (see the
    <a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a> connector), as shown
    in Figure 3a.  The pressures are additive, and each species is assumed to exist at the
    total extensive volume of the phase.  Within a <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a>,
    the <a href="FCSys_Subregions_Phases.html#FCSys.Subregions.Phases">Phases</a> are combined by Amagat's law (see the
    <a href="FCSys_Connectors.html#FCSys.Connectors.InertAmagat">InertAmagat</a> connector), as shown
    in Figure 3b.  The volumes are additive, and each species is assumed to exist at the
    total pressure in the subregion.</p>

    <table border=0 cellspacing=0 cellpadding=2 align=center class=noBorder style="margin-left: auto; margin-right: auto;">
      <tr align=center class=noBorder>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="/media/Storage/Dropbox/Documents/Modelica/FCSys/resources/documentation/Subregions/Species/Species/share_pressure.png">
<br><b>a:</b>  Pressures of species (A, B, and C) are additive within a phase.
        </td>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="/media/Storage/Dropbox/Documents/Modelica/FCSys/resources/documentation/Subregions/Species/Species/share_volume.png">
<br><b>b:</b>  Volumes of phases (I, II, and III) are additive within a subregion.
        </td>
      </tr>
      <tr align=center class=noBorder style="margin-left: auto; margin-right: auto;">
        <td colspan=2 align=center class=noBorder>Figure 3: Methods of attributing pressure and volume.</td>
      </tr>
    </table>

    <p>The following notes apply to the parameters:
    <ul>
    <li>Here (and in the rest of <a href="FCSys.html#FCSys">FCSys</a>), the "specific"
    adjective means that the following extensive quantity is divided by particle number.
    ("Massic" indicates a quantity divided by mass.)</li>
    <li>In general, if dynamic compressibility, dynamic fluidity, or thermal resistivity is zero, then
    it should be set as <code>final</code> so that index reduction may be performed.
    If two <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> instances
    are connected through their <code>inert</code> connectors or faces (<code>xNegative</code>,
    <code>xPositive</code>, etc.) and both have zero generalized resistivities for a
    quantity, then index reduction is necessary.</li>
    <li>Even if an initialization parameter is not selected to be used explicitly,
    it may be used a guess value.</li>
    <li>The <b><i>k</i></b> factor can be used to account for the effects of porosity and tortousity
    on transport.
    It should be changed directly with effective area and inversely with effective length.
    The factor may reflect anisotropic properties; it is a vector with independent components
    for each axis. It affects all of the diffusive transport rates (normal, transverse, and
    thermal) by the same factor.  By default, its components are unity.</li>
    <li>By default, only the x-axis component of linear momentum is included.</li>
    <li>If a state is prescribed, then the
    associated initial condition (IC) will be applied for all time.  The
    corresponding conservation equation will not be imposed.
    If <code>setPartNum</code>, <code>setVelX</code>, <code>setVelY</code>, or <code>setVelZ</code> is
    <code>true</code>, then there may be a secondary effect on the energy conservation equation
    and thus temperature.
    In that case, it may be helpful to set <code>setTemp</code> to <code>true</code> so that
    the energy conservation equation is not imposed.</li>
    <li>If a subregion does not contain any compressible species, then pressure must be prescribed.
    Set <code>setPartNum</code> to <code>true</code> and <code>initMethPartNum</code>
    to <code>InitMethScalar.Pressure</code> for one of the species.</li>
    <li>The <code>start</code> values of the initial conditions for pressure and temperature
    (<i>p</i><sub>IC</sub> and <i>T</i><sub>IC</sub>) are the global default pressure and
    temperature (via the <code>outer</code> instance of the <a href="FCSys_Conditions.html#FCSys.Conditions.Environment">Environment</a> model).
    The <code>start</code> values of the initial conditions for
    other intensive properties (<i>v</i><sub>IC</sub>, <i>h</i><sub>IC</sub>, and
    &mu;<sub>IC</sub>) are related to the initial pressure and temperature
    by the characteristics of the species.  The <code>start</code> value of the
    initial condition for the extensive volume (<i>V</i><sub>IC</sub>) is the volume of the
    subregion, and the <code>start</code> value for particle number (<i>N</i><sub>IC</sub>)
    is related to it via the material characteristics (<code>Data</code>) and the initial pressure and temperature.
    In order to apply other values for any of these initial conditions,
    it may be necessary to do so before translating the model.</li>
    <li>If upstream discretization is not used (<code>upstreamX=false</code>,
    etc.), then the central difference scheme is used.
    <li>If <code>inverseEOS</code> is <code>true</code>, then the equation of state is implemented with pressure
    as a function of temperature and specific volume.  Otherwise, specific volume is a function of temperature
    and pressure.</li></p>

    <p>In evaluating the dynamics of a phase, it is typically assumed that all of the species
    exist at the same velocity and temperature.  The mechanical and thermal time constants
    are usually much shorter than the time span of interest due to the very small coupling
    resistances.  This assumption can be applied in the model by connecting the <code>common</code>
    connectors of the species, which will **

    **    It will cause index reduction during translation.</p>

    <p>In the variables that relate to transport,
    the first index is the axis and the second index is the side.  The sides
    are ordered from negative to positive, according to the
    <a href="FCSys_BaseClasses.html#FCSys.BaseClasses.Side">Side</a> enumeration.
    Shear velocity and force are additionally indexed by
    the orientation of the momentum with respect to the face.
    The orientations are ordered in Cartesian space starting with the axis after the
    normal face, according to the
    <a href="FCSys_BaseClasses.html#FCSys.BaseClasses.Orientation">Orientation</a> enumeration.</p>
    <p>
Extends from <a href="FCSys_BaseClasses_Icons_Names.html#FCSys.BaseClasses.Icons.Names.Top3">FCSys.BaseClasses.Icons.Names.Top3</a>.
<p>

<h3>Parameters</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>Lstar</td><td>&nbsp;</td><td>Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>) [l]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><td>Boolean</td><td>inverseEOS</td><td>true</td><td>Use inverse equation of state</td></tr>
<tr><td>Real</td><td>Xi</td><td>Data.alpha(T)*p</td><td>**Dynamic compressibility (&Xi;)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CompressibilityDynamic">CompressibilityDynamic</a></td><td>x</td><td>Data.Xi(T, p)</td><td>**Dynamic compressibility (&Xi;) [N.T/(l2.m)]</td></tr>
<tr><td>&nbsp;</td><td>F</td><td>Data.F(T, p)</td><td>Dynamic fluidity</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>R</td><td>Data.R(T, p)</td><td>Thermal resistivity</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Prescribed states (via initialization parameters)</td></tr>
<tr><td>Boolean</td><td>setPartNum</td><td>false</td><td>Particle number</td></tr>
<tr><td>Boolean</td><td>setVelX</td><td>false</td><td>X-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelY</td><td>false</td><td>Y-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelZ</td><td>false</td><td>Z-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setTemp</td><td>false</td><td>Temperature</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Scalar properties</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethPartNum</td><td>InitMethScalar.Pressure</td><td>Method of initializing the particle number</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethTemp</td><td>InitMethScalar.Temperature</td><td>Method of initializing the temperature</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>derN_IC</td><td>0</td><td>Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">VolumeSpecific</a></td><td>v_IC</td><td>&nbsp;</td><td>Initial specific volume (<i>v</i><sub>IC</sub>) [l3/N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecificRate">VolumeSpecificRate</a></td><td>derv_IC</td><td>0</td><td>Initial rate of specific volume ((&part;<i>v</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/(N.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">VolumeRate</a></td><td>derV_IC</td><td>0</td><td>Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">PressureRate</a></td><td>derp_IC</td><td>0</td><td>Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>) [m/(l.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">TemperatureRate</a></td><td>derT_IC</td><td>0</td><td>Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>derh_IC</td><td>0</td><td>Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>mu_IC</td><td>&nbsp;</td><td>Initial electrochemical potential (&mu;<sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>dermu_IC</td><td>0</td><td>Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>Ndot_IC</td><td>0</td><td>Initial reaction rate (<i>N&#775;</i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Velocity</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethX</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the x-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethY</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the y-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethZ</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the z-axis component</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>{0,0,0}</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Acceleration">Acceleration</a></td><td>derphi_IC[Axis]</td><td>{0,0,0}</td><td>Initial acceleration ((&part;<b>&phi;</b>/&part;<i>t</i>)<sub>IC</sub>) [l/T2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>I_IC[Axis]</td><td>{0,0,0}</td><td>Initial current (<i><b>I</b></i><sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CurrentRate">CurrentRate</a></td><td>derI_IC[Axis]</td><td>{0,0,0}</td><td>Initial rate of current ((&part;<i><b>I</b></i>/&part;<i>t</i>)<sub>IC</sub>) [N/T2]</td></tr>
</table>
<p>

<h3>Connectors</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">ChemicalOutput</a></td><td>chemical</td><td>Connector to exchange material while advecting linear momentum and energy</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>common</td><td>Connector to directly couple velocities and temperatures of multiple species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inert</td><td>Connector to exchange linear momentum and heat by diffusion, with additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>faces[Axis, Side]</td><td>Face connectors to transport material, linear momentum, and heat</td></tr>
</table>
<p>

<h3>Modelica definition</h3>

<pre>
<font color="blue">model</font> Species <font color="darkgreen">
  &quot;Model for single-species exchange, transport, and storage of material, linear momentum, and energy&quot;</font>
  <font color="blue">import </font><a href="http://build.openmodelica.org/Documentation/Modelica.Math.html#Modelica.Math.log10">Modelica.Math.log10</a>;
  <font color="blue">extends </font><a href="FCSys_BaseClasses_Icons_Names.html#FCSys.BaseClasses.Icons.Names.Top3">FCSys.BaseClasses.Icons.Names.Top3</a>;
  <font color="darkgreen">// **fix icon and diagram</font>

  <font color="darkgreen">// Geometric parameters</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> Lstar(
    min=Modelica.Constants.small,
    nominal=10*U.m,
    start=1e3*<font color="red">product</font>(L)^(1/3)) <font color="darkgreen">
    &quot;Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>)&quot;</font>;

  <font color="darkgreen">// Material properties</font>
  <font color="blue">replaceable </font><font color="blue">package</font> Data = <a href="FCSys_Characteristics_BaseClasses_Characteristic.html#FCSys.Characteristics.BaseClasses.Characteristic">Characteristics.BaseClasses.Characteristic</a> <font color="blue">
    constrainedby </font>Characteristics.BaseClasses.Characteristic <font color="darkgreen">
    &quot;Characteristic data&quot;</font>;
  <font color="blue">parameter </font>Boolean inverseEOS=true <font color="darkgreen">&quot;Use inverse equation of state&quot;</font>;

  <font color="darkgreen">// Assumptions</font>
  <font color="darkgreen">// -----------</font>
  <font color="darkgreen">// Dynamics</font>
  <font color="blue">parameter </font>Boolean setPartNum=false <font color="darkgreen">&quot;Particle number&quot;</font>;
  <font color="blue">parameter </font>Boolean setVelX=false <font color="darkgreen">&quot;X-axis component of velocity&quot;</font>;
  <font color="blue">parameter </font>Boolean setVelY=false <font color="darkgreen">&quot;Y-axis component of velocity&quot;</font>;
  <font color="blue">parameter </font>Boolean setVelZ=false <font color="darkgreen">&quot;Z-axis component of velocity&quot;</font>;
  <font color="blue">parameter </font>Boolean setTemp=false <font color="darkgreen">&quot;Temperature&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Upstream discretization</font>
  <font color="blue">parameter </font>Boolean upstreamX=true <font color="darkgreen">&quot;X&quot;</font>;
  <font color="blue">parameter </font>Boolean upstreamY=true <font color="darkgreen">&quot;Y&quot;</font>;

  <font color="blue">parameter </font>Boolean upstreamZ=true <font color="darkgreen">&quot;Z&quot;</font>;

  <font color="darkgreen">// Initialization parameters</font>
  <font color="darkgreen">// -------------------------</font>
  <font color="darkgreen">// Scalar properties</font>
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">BaseClasses.InitMethScalar</a> initMethPartNum=InitMethScalar.Pressure <font color="darkgreen">
    &quot;Method of initializing the particle number&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">BaseClasses.InitMethScalar</a> initMethTemp=InitMethScalar.Temperature <font color="darkgreen">
    &quot;Method of initializing the temperature&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N_IC(start=V_IC/v_IC) <font color="darkgreen">
    &quot;Initial particle number (<i>N</i><sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">// Note:  This parameter is left enabled even it isn&#39;t used to</font>
  <font color="darkgreen">// explicitly initialize any states, since it&#39;s used as a guess value.</font>
  <font color="darkgreen">// Similar notes apply to some other initial conditions below.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> derN_IC=0 <font color="darkgreen">
    &quot;Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">// Note:  Dymola 7.4 doesn&#39;t recognize enumerations in the dialog enable</font>
  <font color="darkgreen">// option, e.g.,</font>
  <font color="darkgreen">//     enable=initMethPartNum == InitMethScalar.AmountRate.</font>
  <font color="darkgreen">// Therefore, the values of the enumerations are specified numerically for</font>
  <font color="darkgreen">// this initial condition and some others below.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">Q.VolumeSpecific</a> v_IC(min=Modelica.Constants.small, start=<font color="red">Data.v_Tp</font>
        (T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial specific volume (<i>v</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecificRate">Q.VolumeSpecificRate</a> derv_IC=0 <font color="darkgreen">
    &quot;Initial rate of specific volume ((&part;<i>v</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V_IC(start=<font color="red">product</font>(L)) <font color="darkgreen">
    &quot;Initial volume (<i>V</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">Q.VolumeRate</a> derV_IC=0 <font color="darkgreen">
    &quot;Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p_IC(start=environment.p) <font color="darkgreen">
    &quot;Initial pressure (<i>p</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">Q.PressureRate</a> derp_IC=0 <font color="darkgreen">
    &quot;Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T_IC(nominal=298.15*U.K, start=environment.T)
    <font color="darkgreen">&quot;Initial temperature (<i>T</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">Q.TemperatureRate</a> derT_IC=0 <font color="darkgreen">
    &quot;Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h_IC(start=<font color="red">Data.h</font>(T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial specific enthalpy (<i>h</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">Q.PotentialRate</a> derh_IC=0 <font color="darkgreen">
    &quot;Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> mu_IC(start=<font color="red">Data.g</font>(T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial electrochemical potential (&mu;<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">Q.PotentialRate</a> dermu_IC=0 <font color="darkgreen">
    &quot;Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> Ndot_IC=0 <font color="darkgreen">
    &quot;Initial reaction rate (<i>N&#775;</i><sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Velocity</font>
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethX=InitMethVelocity.Velocity <font color="darkgreen">
    &quot;Method of initializing the x-axis component&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethY=InitMethVelocity.Velocity <font color="darkgreen">
    &quot;Method of initializing the y-axis component&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethZ=InitMethVelocity.Velocity <font color="darkgreen">
    &quot;Method of initializing the z-axis component&quot;</font>;
  <font color="darkgreen">// Note:  Dymola 7.4 doesn&#39;t provide pull-down lists for arrays of</font>
  <font color="darkgreen">// enumerations; therefore, a parameter is used for each axis.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial velocity (<b>&phi;</b><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Acceleration">Q.Acceleration</a> derphi_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial acceleration ((&part;<b>&phi;</b>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> I_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial current (<i><b>I</b></i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.CurrentRate">Q.CurrentRate</a> derI_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial rate of current ((&part;<i><b>I</b></i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;

  <font color="darkgreen">// Material properties</font>
  Real Xi(nominal=10*U.cm*U.atm/U.A) = <font color="red">Data.alpha</font>(T)*p <font color="darkgreen">
    &quot;**Dynamic compressibility (&Xi;)&quot;</font>;
  <font color="darkgreen">// **add and use quantity for M.L2/N.T</font>
  <font color="darkgreen">// **Add function to Characteristic</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.CompressibilityDynamic">Q.CompressibilityDynamic</a> x(nominal=1e8/(U.V*U.s)) = <font color="red">Data.Xi</font>(T, p) <font color="darkgreen">
    &quot;**</pre>Dynamic compressibility (&Xi;)&quot;</font>;
  <font color="darkgreen">// **Dimension</font>
  Q.FluidityDynamic F(nominal=10*U.cm*U.s/U.g) = <font color="red">Data.F</font>(T, p) <font color="darkgreen">
    &quot;Dynamic fluidity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">Q.ResistivityThermal</a> R(nominal=10*U.cm/U.A) = <font color="red">Data.R</font>(T, p) <font color="darkgreen">
    &quot;Thermal resistivity&quot;</font>;

  <font color="darkgreen">// Preferred states</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N(
    nominal=4*U.C,
    <font color="blue">final </font>start=N_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Particle number&quot;</font>;
  <font color="darkgreen">// Note:  The start value for this variable (and others below) isn&#39;t fixed</font>
  <font color="darkgreen">// because the related initial condition is applied in the initial</font>
  <font color="darkgreen">// equation section.</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi[n_lin](
    <font color="blue">each </font>nominal=U.cm/U.s,
    <font color="blue">final </font>start=phi_IC[cartAxes],
    <font color="blue">each </font><font color="blue">final </font>fixed=false,
    <font color="blue">each </font>stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Velocity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T(
    nominal=298.15*U.K,
    <font color="blue">final </font>start=T_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Temperature&quot;</font>;

  <font color="darkgreen">// Aliases (for common terms)</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p(
    nominal=U.atm,
    <font color="blue">final </font>start=p_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Pressure&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Mass">Q.Mass</a> M(
    nominal=1e-3*U.g,
    start=Data.m*N_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Mass&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V(
    nominal=U.cc,
    <font color="blue">final </font>start=V_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Volume&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">Q.VolumeSpecific</a> v(
    nominal=U.cc/(4*U.C),
    <font color="blue">final </font>start=v_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Specific volume&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h(
    nominal=U.V,
    <font color="blue">final </font>start=h_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Specific enthalpy&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> I[n_lin](
    <font color="blue">each </font>nominal=U.A,
    <font color="blue">final </font>start=I_IC[cartAxes],
    <font color="blue">each </font><font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Current&quot;</font>;

  <font color="darkgreen">// Auxiliary variables (for analysis)</font>
  <font color="darkgreen">// ----------------------------------</font>
  <font color="darkgreen">// Misc. properties and conditions</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> mu(stateSelect=StateSelect.never) = chemical.mu <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Electrochemical potential&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> s(stateSelect=StateSelect.never) = <font color="red">Data.s</font>(T, p) <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Specific entropy&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> S(stateSelect=StateSelect.never) = N*s <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Entropy&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> q[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = Data.m
    *phi .* I ./ (2*A[cartAxes]) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Dynamic pressure&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.CapacityThermalSpecific">Q.CapacityThermalSpecific</a> c_v(stateSelect=StateSelect.never) = <font color="red">
    Data.c_v</font>(T, p) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Isochoric specific heat capacity&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureReciprocal">Q.PressureReciprocal</a> beta_T(stateSelect=StateSelect.never) = <font color="red">
    Data.beta_T</font>(T, p) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Isothermal static compressibility&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Time constants</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_exch_mechanical(stateSelect=StateSelect.never) =
    halfalpha_F*N/Lstar <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constant for mechanical exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_exch_thermal(stateSelect=StateSelect.never) = halfalpha_R*N/
    Lstar <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Time constant for thermal exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_material(stateSelect=StateSelect.never) = <font color="red">noEvent</font>(<font color="blue">if </font>
    halfalpha_Xi &gt; Modelica.Constants.small<font color="blue"> then </font>Data.m*beta_T/halfalpha_Xi<font color="blue">
     else </font>0) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Time constant for material transport&quot;</font>;
  <font color="darkgreen">// **Note that this isn&#39;t dependent on length or area---only intensive</font>
  <font color="darkgreen">// properties.</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_normal[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    fill</font>(halfalpha_Xi*N, n_lin) ./ Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Time constants for normal mechanical transport&quot;</font>;
  <font color="darkgreen">// **Note that only for the axes with linear momentum included; others are</font>
  <font color="darkgreen">// infinite</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_transverse[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never)
     = <font color="red">fill</font>(halfalpha_F*N, n_lin) ./ Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Time constants for transverse mechanical transport&quot;</font>;
  <font color="darkgreen">// **Note that only for the axes with linear momentum included; others are</font>
  <font color="darkgreen">// infinite</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_thermal[Axis](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    fill</font>(halfalpha_R*N, 3) ./ Lstar_trans <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constants for thermal transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> eta(stateSelect=StateSelect.never) = <font color="red">log10</font>(<font color="red">max</font>({
    tau_exch_mechanical,tau_exch_thermal,<font color="red">max</font>([tau_trans_normal;
    tau_trans_transverse; tau_trans_thermal])})) - <font color="red">log10</font>(<font color="red">min</font>({
    tau_exch_mechanical,tau_exch_thermal,<font color="red">min</font>([tau_trans_normal;
    tau_trans_transverse; tau_trans_thermal])})) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Range of time constants in order of magnitude&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Peclet numbers (only for the axes with linear momentum included; others are</font>
  <font color="darkgreen">// zero)</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_0[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = I*
    halfalpha_Xi ./ Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Normal Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_12[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = I*
    halfalpha_F ./ Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Transverse Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_therm[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = I*
    halfalpha_R ./ Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Thermal Peclet numbers&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Bulk flow rates</font>
  <font color="darkgreen">/* **indexing error
  output Q.Force mphiI[n_lin, Orientation](each stateSelect=StateSelect.never)
     = {(if inclLin[cartWrap(cartAxes[axis] + orientation)] then Data.m*phi[
    linAxes[cartWrap(cartAxes[axis] + orientation)]]*I[axis] else 0) for
    orientation in Orientation, axis in 1:n_lin} if n_lin &gt; 0 and environment.analysis
    &quot;Bulk rate of mechanical advection&quot;;
  */</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> TsI[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = T*s*I <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Bulk rate of thermal advection&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Linear momentum balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> Ma[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = M*(<font color="red">der</font>(phi)/U.s
     - environment.a[cartAxes]) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force relative to the frame of reference (constant mass)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_exch_adv[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) =
    chemical.mPhidot - Data.m*phi*chemical.Ndot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force due to advective exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_exch_diff[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) =
    common.mechanical.mPhidot + inert.mPhidot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Friction from other species (diffusive exchange)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_trans_adv[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = Data.m
    *{phi_face_0[cartAxes[axis], :]*faces[cartAxes[axis], :].Ndot + <font color="red">sum</font>(faces[<font color="red">
    cartWrap</font>(cartAxes[axis] - orientation), :].phi[orientation]*faces[<font color="red">cartWrap</font>(
    cartAxes[axis] - orientation), :].Ndot <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation) <font color="blue">for </font>
    axis<font color="blue"> in </font>1:n_lin} <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force due to advective transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_trans_diff[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = {<font color="red">
    Delta</font>(faces[cartAxes[axis], :].p)*A[cartAxes[axis]] + <font color="red">sum</font>(<font color="red">Sigma</font>(faces[<font color="red">
    cartWrap</font>(cartAxes[axis] - orientation), :].mPhidot[orientation]) <font color="blue">for </font>
    orientation<font color="blue"> in </font>Orientation) <font color="blue">for </font>axis<font color="blue"> in </font>1:n_lin} <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Friction from other subregions (diffusive transport; includes volume viscosity)&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Energy balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Ndere(stateSelect=StateSelect.never) = (M*<font color="red">der</font>(phi*phi)/2 + N*<font color="red">
    der</font>(h) - V*<font color="red">der</font>(p))/U.s <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of energy storage (internal and kinetic) at constant mass&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Wdot_exch(stateSelect=StateSelect.never) = -(chemical.phi*
    chemical.mPhidot/2 + (Data.m*(chemical.hbar - phi*phi/2) - h)*chemical.Ndot)
    <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Relative rate of work (internal, flow, and kinetic) done by chemical exchange (advection)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_gen_exch(stateSelect=StateSelect.never) = phi*common.mechanical.mPhidot
     + inert.phi*inert.mPhidot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of heat generation due to friction with other species&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_exch(stateSelect=StateSelect.never) = common.thermal.Qdot +
    inert.Qdot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of thermal conduction from other species&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Wdot_trans(stateSelect=StateSelect.never) = -<font color="red">sum</font>(<font color="red">sum</font>((Data.m*(
    phi_face_0[axis, side]^2 + faces[axis, side].phi*faces[axis, side].phi)/2 + <font color="red">
    Data.h</font>(faces[axis, side].T, faces[axis, side].p) - Data.m*phi*phi/2 - h)*
    faces[axis, side].Ndot <font color="blue">for </font>side<font color="blue"> in </font>Side) <font color="blue">for </font>axis<font color="blue"> in </font>Axis) <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Relative rate of work (internal, flow, and kinetic) done by advective transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_gen_trans(stateSelect=StateSelect.never) = <font color="red">sum</font>(faces.phi .*
    faces.mPhidot) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of heat generation due to friction with other subregions&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_trans(stateSelect=StateSelect.never) = <font color="red">sum</font>(faces.Qdot) <font color="blue">
    if </font>environment.analysis <font color="darkgreen">&quot;Rate of thermal conduction from other subregions&quot;</font>;
  <font color="darkgreen">// Note:  These auxiliary variables should not be used as states (hence</font>
  <font color="darkgreen">// StateSelect.never); the structure of the problem should not change if</font>
  <font color="darkgreen">// they are included.</font>

  <a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">Connectors.ChemicalOutput</a> chemical(
    <font color="blue">final </font>n_lin=n_lin,
    <font color="blue">final </font>m=Data.m,
    <font color="blue">final </font>formula=Data.formula,
    mu(<font color="blue">final </font>start=mu_IC,<font color="blue">final </font>fixed=false),
    phi(<font color="blue">final </font>start=phi_IC[cartAxes]),
    Ndot(<font color="blue">final </font>start=Ndot_IC,<font color="blue">final </font>fixed=false),
    hbar(<font color="blue">final </font>start=<font color="red">Data.h</font>(T_IC, p_IC)/Data.m)) <font color="darkgreen">
    &quot;Connector to exchange material while advecting linear momentum and energy&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Connectors.Inert</a> common(
    <font color="blue">final </font>n_lin=n_lin,
    mechanical(phi(<font color="blue">final </font>start=phi_IC[cartAxes], <font color="blue">each </font><font color="blue">final </font>fixed=false)),
    thermal(T(<font color="blue">final </font>start=T_IC, <font color="blue">final </font>fixed=false))) <font color="darkgreen">
    &quot;Connector to directly couple velocities and temperatures of multiple species&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">Connectors.InertDalton</a> inert(
    <font color="blue">final </font>n_lin=n_lin,
    V(
      min=0,
      <font color="blue">final </font>start=V_IC,
      <font color="blue">final </font>fixed=false),
    p(<font color="blue">final </font>start=p_IC, <font color="blue">final </font>fixed=false),
    phi(start=phi_IC[cartAxes]),
    T(start=T_IC)) <font color="darkgreen">
    &quot;Connector to exchange linear momentum and heat by diffusion, with additivity of pressure&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Face">Connectors.Face</a> faces[Axis, Side](
    p(<font color="blue">each </font>start=p_IC),
    Ndot(start=<font color="red">outerProduct</font>(I_IC, {1,-1})),
    phi(start={{<font color="red">fill</font>(phi_IC[<font color="red">cartWrap</font>(axis + orientation)], 2) <font color="blue">for </font>orientation<font color="blue">
           in </font>Orientation} <font color="blue">for </font>axis<font color="blue"> in </font>Axis}),
    mPhidot(<font color="blue">each </font>start=0),
    T(<font color="blue">each </font>start=T_IC),
    Qdot(<font color="blue">each </font>start=0)) <font color="darkgreen">
    &quot;Face connectors to transport material, linear momentum, and heat&quot;</font>;

  <font color="darkgreen">// Geometric parameters</font>

<font color="blue">protected </font>
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> L[Axis] <font color="darkgreen">&quot;Length&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Area">Q.Area</a> A[Axis] <font color="darkgreen">&quot;Cross-sectional area&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> Lstar_trans[Axis] <font color="darkgreen">
    &quot;Effective cross-sectional area per length&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Boolean inclLin[Axis] <font color="darkgreen">
    &quot;true, if each component of linear momentum is included&quot;</font>;
  <font color="darkgreen">// **={true,true,true}</font>
  <font color="darkgreen">// Even though this parameter is set as final within the constrainedby</font>
  <font color="darkgreen">// clauses of the models in the Phases package, Dymola 7.4 still shows</font>
  <font color="darkgreen">// it in the parameter dialog (hence the &quot;Do not adjust&quot;).</font>
  <font color="darkgreen">//</font>
  <font color="blue">outer </font><font color="blue">parameter </font>Integer n_lin <font color="darkgreen">&quot;Number of components of linear momentum&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Integer linAxes[:] <font color="darkgreen">
    &quot;Linear momentum component indices of the Cartesian axes&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Integer cartAxes[:] <font color="darkgreen">
    &quot;Cartesian-axis indices of the components of linear momentum&quot;</font>;
  <font color="darkgreen">// Note:  The size is n_lin, but it can&#39;t be specified here due to an error</font>
  <font color="darkgreen">// in Dymola 7.4.</font>
  <font color="blue">final </font><font color="blue">parameter </font>Boolean upstream[Axis]={upstreamX,upstreamY,upstreamZ} <font color="darkgreen">
    &quot;true, if each Cartesian axis uses upstream discretization&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Boolean setVel[Axis]={setVelX,setVelY,setVelZ} <font color="darkgreen">
    &quot;true, if each component of linear momentum is prescribed&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethVel[Axis]={initMethX,
      initMethY,initMethZ} <font color="darkgreen">&quot;Initialization methods for velocity&quot;</font>;

  <font color="darkgreen">// Base resistivity factors</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> halfalpha_x(nominal=5*U.cm/U.A) = x/(2*p) <font color="darkgreen">
    &quot;Half of base resistivity factor for self diffusivity**&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> halfalpha_Xi(nominal=5*U.cm/U.A) = Xi*Data.m*v/2 <font color="darkgreen">
    &quot;**fix Half of base resistivity factor for dynamic compressibility&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> halfalpha_F(nominal=5*U.cm/U.A) = F*Data.m/2 <font color="darkgreen">
    &quot;Half of base resistivity factor for dynamic fluidity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> halfalpha_R(nominal=5*U.cm/U.A) = R*<font color="red">Data.c_v</font>(T, p)/2 <font color="darkgreen">
    &quot;Half of base resistivity factor for thermal resistivity&quot;</font>;

  <font color="darkgreen">// **Efforts and flows of the conditional connectors</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_face_0[Axis, Side](<font color="blue">each </font>nominal=U.cm/U.s,start=<font color="red">fill</font>(
        v_IC,
        3,
        2)) <font color="darkgreen">&quot;Normal velocities at the faces&quot;</font>;
  <font color="darkgreen">// **fix start values</font>

  <font color="blue">outer </font><a href="FCSys_Conditions.html#FCSys.Conditions.Environment">FCSys.Conditions.Environment</a> environment <font color="darkgreen">&quot;Environmental conditions&quot;</font>;
  <font color="darkgreen">// Note:  In Dymola 7.4 it&#39;s necessary to add the missing inner message</font>
  <font color="darkgreen">// here to give a warning message, even though it&#39;s included in the</font>
  <font color="darkgreen">// Environment model too.</font>

<font color="blue">initial </font><font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font><font color="red">size</font>(chemical, 1)<font color="blue"> loop</font>
    <font color="red">assert</font>(chemical[i].formula == Data.formula, &quot;**&quot;);
  <font color="blue">end for</font>;

  <font color="darkgreen">// Check that the initialization methods are valid.</font>
  <font color="red">assert</font>(initMethPartNum &lt;&gt; initMethTemp<font color="blue"> or </font>initMethPartNum == InitMethScalar.None,
    &quot;The initialization methods for particle number and temperature cannot be the same (unless None).&quot;);
  <font color="blue">if </font><font color="blue">not </font>Data.isCompressible<font color="blue"> then</font>
    <font color="red">assert</font>(initMethPartNum &lt;&gt; InitMethScalar.Pressure<font color="blue"> and </font>initMethPartNum &lt;&gt;
      InitMethScalar.PressureRate<font color="blue"> or </font>setPartNum, &quot;The material is incompressible,
      yet the initialization method for particle number involves pressure.&quot;);
    <font color="red">assert</font>(initMethTemp &lt;&gt; InitMethScalar.Pressure<font color="blue"> and </font>initMethTemp &lt;&gt;
      InitMethScalar.PressureRate<font color="blue"> or </font>setTemp, &quot;The material is incompressible,
      yet the initialization method for temperature involves pressure.&quot;);
    <font color="blue">if </font><font color="blue">not </font>Data.hasThermalExpansion<font color="blue"> then</font>
      <font color="red">assert</font>(initMethPartNum &lt;&gt; InitMethScalar.VolumeSpecific<font color="blue"> and </font>
        initMethPartNum &lt;&gt; InitMethScalar.VolumeSpecificRate<font color="blue"> or </font>setPartNum, &quot;The material is isochoric,
      yet the initialization method for particle number involves specific volume.&quot;);
      <font color="red">assert</font>(initMethTemp &lt;&gt; InitMethScalar.VolumeSpecific<font color="blue"> and </font>initMethTemp &lt;&gt;
        InitMethScalar.VolumeSpecificRate<font color="blue"> or </font>setPartNum, &quot;The material is isochoric,
      yet the initialization method for temperature involves specific volume.&quot;);
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">/* This is commented out because it may be annoying.
  // Warn when index reduction may be necessary.
  if abs(Xi) &lt; Modelica.Constants.small then
    Modelica.Utilities.Streams.print(&quot;Warning: The dynamic compressibility is zero.
    This may directly couple the densities within neighboring subregions.
Consider setting the value of Xi as final (if not already) so that index reduction may be performed.&quot;);
  end if;
  if abs(F) &lt; Modelica.Constants.small then
    Modelica.Utilities.Streams.print(&quot;Warning: The dynamic fluidity is zero.
    This may directly couple the velocity of this species with others within the subregion or with the same species within neighboring subregions.
Consider setting the value of F as final (if not already) so that index reduction may be performed.&quot;);
  end if;
  if abs(R) &lt; Modelica.Constants.small then
    Modelica.Utilities.Streams.print(&quot;Warning: The thermal resistivity is zero.
    This may directly couple the temperature of this species with others within the subregion or with the same species within neighboring subregions.
Consider setting the value of R as final (if not already) so that index reduction may be performed.&quot;);
  end if;
  // Note:  According to the Modelica specification (&gt;=3.0), these
  // checks should be possible using the assert() command with
  // level=AssertionLevel.warning.  However, this isn&#39;t supported in
  // Dymola 7.4 or FD2012.
  */</font>

  <font color="darkgreen">// Particle number</font>
  <font color="blue">if </font>setPartNum<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected, since the state is prescribed.</font>
    <font color="red">assert</font>(initMethPartNum &lt;&gt; InitMethScalar.None, &quot;The state for particle number is prescribed,
yet its condition is not defined.
Choose a condition besides None.&quot;);
  <font color="blue">else</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initMethPartNum == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecific<font color="blue"> then</font>
      v = v_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecificRate<font color="blue"> then</font>
      <font color="red">der</font>(v)/U.s = derv_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      chemical.mu = mu_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(chemical.mu)/U.s = dermu_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.ReactionRate<font color="blue"> then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Else, initMethPartNum == InitMethScalar.None; then, there are no</font>
      <font color="darkgreen">// initial equations.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Velocity</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>Axis<font color="blue"> loop</font>
    <font color="blue">if </font>inclLin[axis]<font color="blue"> then</font>
      <font color="blue">if </font>setVel[axis]<font color="blue"> then</font>
        <font color="darkgreen">// Ensure that a condition is selected, since the state is</font>
        <font color="darkgreen">// prescribed.</font>
        <font color="red">assert</font>(initMethVel[axis] &lt;&gt; InitMethVelocity.None, &quot;The state for the &quot; +
          {&quot;x&quot;,&quot;y&quot;,&quot;z&quot;}[axis] + &quot;-axis component of linear momentum is prescribed,
yet its condition is not defined.
Choose any condition besides None.&quot;);
      <font color="blue">else</font>
        <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
        <font color="blue">if </font>initMethVel[axis] == InitMethVelocity.Velocity<font color="blue"> then</font>
          phi[linAxes[axis]] = phi_IC[axis];
        <font color="blue">elseif </font>initMethVel[axis] == InitMethVelocity.Acceleration<font color="blue"> then</font>
          <font color="red">der</font>(phi[linAxes[axis]])/U.s = derphi_IC[axis];
        <font color="blue">elseif </font>initMethX == InitMethVelocity.Current<font color="blue"> then</font>
          I[linAxes[axis]] = I_IC[axis];
        <font color="blue">elseif </font>initMethVel[axis] == InitMethVelocity.CurrentRate<font color="blue"> then</font>
          <font color="red">der</font>(I[linAxes[axis]])/U.s = derI_IC[axis];
          <font color="darkgreen">// Else, initMethVel[axis] == InitMethVelocity.None; then, there are</font>
          <font color="darkgreen">// no initial equations.</font>
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Temperature</font>
  <font color="blue">if </font>setTemp<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected, since the state is prescribed.</font>
    <font color="red">assert</font>(initMethTemp &lt;&gt; InitMethScalar.None, &quot;The state for temperature is prescribed,
yet its condition is not defined.
Choose a condition besides None.&quot;);
  <font color="blue">else</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initMethTemp == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecific<font color="blue"> then</font>
      v = v_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecificRate<font color="blue"> then</font>
      <font color="red">der</font>(v)/U.s = derv_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      chemical.mu = mu_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(chemical.mu)/U.s = dermu_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.ReactionRate<font color="blue"> then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Else, initMethTemp == InitMethScalar.None; then, there are no</font>
      <font color="darkgreen">// initial equations.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

<font color="blue">equation </font>
  <font color="darkgreen">/*

      equation
  // Chemical equilibrium
  0 = nu*chemical.mu;

  // Conservation (no storage)
  nu[1:n_spec]*Ndot = chemical.Ndot &quot;Material&quot;;
  zeros(n_lin) = sum(chemical[i].mPhidot for i in 1:n_spec) &quot;Linear momentum&quot;;
  0 = sum(chemical.Hdot) &quot;Energy&quot;;

  // Ideal mixing/upstream discretization
  // Chemical species
  for i in 1:n_spec loop
    chemical[i].mPhidot = semiLinear(
      chemical[i].m*chemical[i].Ndot,
      chemical[i].phi,
      phi) &quot;Linear momentum&quot;;
    chemical[i].Hdot = semiLinear(
      chemical[i].m*chemical[i].Ndot,
      chemical[i].hbar,
      hbar) &quot;Energy&quot;;
  end for;
  */</font>
  <font color="darkgreen">// Aliases (only for clarity)</font>
  p = inert.p;
  V = inert.V;
  v*N = V;
  T = common.thermal.T;
  phi = common.mechanical.phi;
  N*phi = L[cartAxes] .* I;
  M = Data.m*N;

  <font color="darkgreen">// Thermodynamic correlations</font>
  <font color="blue">if </font>inverseEOS<font color="blue"> then</font>
    p = <font color="red">Data.p_Tv</font>(T, V/N);
  <font color="blue">else</font>
    V = N*<font color="red">Data.v_Tp</font>(T, p);
  <font color="blue">end if</font>;
  h = <font color="red">Data.h</font>(T, p);
  h = chemical.mu + T*<font color="red">Data.s</font>(T, p);
  <font color="darkgreen">// p = chemical.mu &quot;**temp, use above eq.&quot;;</font>
  phi_face_0 = {{1,-1} .* <font color="red">Data.v_Tp</font>(faces[axis, :].T, faces[axis, :].p) .*
    faces[axis, :].Ndot/A[axis] <font color="blue">for </font>axis<font color="blue"> in </font>Axis};

  <font color="darkgreen">// Exchange</font>
  <font color="darkgreen">// --------</font>
  <font color="darkgreen">// Material</font>
  chemical.mPhidot = <font color="red">semiLinear</font>(
    Data.m*chemical.Ndot,
    chemical.phi,
    phi) <font color="darkgreen">&quot;Advection&quot;</font>;
  F*inert.mPhidot = 2*Lstar*(inert.phi - phi) <font color="darkgreen">&quot;Diffusion&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Fluid/thermal</font>
  chemical.Hdot = <font color="red">semiLinear</font>(
    chemical.Ndot,
    chemical.hbar*Data.m,
    h) <font color="darkgreen">&quot;Advection&quot;</font>;
  R*inert.Qdot = 2*Lstar*(inert.T - T) <font color="darkgreen">&quot;Diffusion&quot;</font>;

  <font color="darkgreen">// Transport</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>Axis<font color="blue"> loop</font>
    <font color="blue">for </font>side<font color="blue"> in </font>Side<font color="blue"> loop</font>
      <font color="darkgreen">// Material</font>
      (x/Lstar_trans[axis] + 4*Xi/N)*(faces[axis, side].Ndot - (<font color="blue">if </font>inclLin[axis]<font color="blue">
         then </font><font color="red">inSign</font>(side)*I[linAxes[axis]]<font color="blue"> else </font>0)) = (faces[axis, side].p - p)
        *(<font color="blue">if </font>upstream[axis]<font color="blue"> and </font>inclLin[axis]<font color="blue"> then </font>1 + <font color="red">exp</font>(-<font color="red">inSign</font>(side)*I[
        linAxes[axis]]*halfalpha_x/Lstar_trans[axis])<font color="blue"> else </font>2);
      <font color="darkgreen">// **fix or remove effect of Peclet number</font>
      <font color="darkgreen">// **temp 0 factor</font>
      <font color="darkgreen">// **Make connectors non-conditional, remove alias variables</font>
      <font color="darkgreen">// **Include bulk viscosity in Peclet number</font>
      <font color="darkgreen">// **Material resistance/ivity-&gt;Self resistance/ivity</font>
      <font color="darkgreen">// **update peclet numbers in these transport equations and the outputs above--see dissertation.</font>
      <font color="darkgreen">// Transverse</font>
      <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation<font color="blue"> loop</font>
        F*faces[axis, side].mPhidot[orientation] = Lstar_trans[axis]*(faces[
          axis, side].phi[orientation] - (<font color="blue">if </font>inclLin[<font color="red">cartWrap</font>(axis +
          orientation)]<font color="blue"> then </font>phi[linAxes[<font color="red">cartWrap</font>(axis + orientation)]]<font color="blue"> else </font>0))
          *(<font color="blue">if </font>inclLin[axis]<font color="blue"> and </font>upstream[axis]<font color="blue"> then </font>1 + <font color="red">exp</font>(-<font color="red">inSign</font>(side)*I[
          linAxes[axis]]*halfalpha_F/Lstar_trans[axis])<font color="blue"> else </font>2);
      <font color="blue">end for</font>;

      <font color="darkgreen">// Thermal</font>
      R*faces[axis, side].Qdot = Lstar_trans[axis]*(faces[axis, side].T - T)*(<font color="blue">
        if </font>inclLin[axis]<font color="blue"> and </font>upstream[axis]<font color="blue"> then </font>1 + <font color="red">exp</font>(-<font color="red">inSign</font>(side)*I[
        linAxes[axis]]*halfalpha_R/Lstar_trans[axis])<font color="blue"> else </font>2);
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Material dynamics</font>
  <font color="blue">if </font>setPartNum<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC for all time (material not conserved).</font>
    <font color="blue">if </font>initMethPartNum == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecific<font color="blue"> then</font>
      v = v_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecificRate<font color="blue"> then</font>
      <font color="red">der</font>(v)/U.s = derv_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      chemical.mu = mu_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(chemical.mu)/U.s = dermu_IC;
    <font color="blue">else</font>
      <font color="darkgreen">// if initMethPartNum == InitMethScalar.ReactionRate then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Note:  initMethPartNum == InitMethScalar.None can&#39;t occur due to an</font>
      <font color="darkgreen">// assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    <font color="red">der</font>(N)/U.s = chemical.Ndot + <font color="red">sum</font>(faces.Ndot) <font color="darkgreen">&quot;Material conservation&quot;</font>;
    <font color="darkgreen">// **temp last term</font>
  <font color="blue">end if</font>;

  <font color="darkgreen">// Mechanical dynamics</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>1:n_lin<font color="blue"> loop</font>
    <font color="blue">if </font>setVel[cartAxes[axis]]<font color="blue"> then</font>
      <font color="darkgreen">// Apply the IC for all time (linear momentum isn&#39;t conserved along</font>
      <font color="darkgreen">// this axis).</font>
      <font color="blue">if </font>initMethVel[cartAxes[axis]] == InitMethVelocity.Velocity<font color="blue"> then</font>
        phi[axis] = phi_IC[cartAxes[axis]];
      <font color="blue">elseif </font>initMethVel[cartAxes[axis]] == InitMethVelocity.Acceleration<font color="blue"> then</font>
        <font color="red">der</font>(phi[axis])/U.s = derphi_IC[cartAxes[axis]];
      <font color="blue">elseif </font>initMethX == InitMethVelocity.Current<font color="blue"> then</font>
        I[axis] = I_IC[cartAxes[axis]];
      <font color="blue">elseif </font>initMethVel[cartAxes[axis]] == InitMethVelocity.CurrentRate<font color="blue"> then</font>
        <font color="red">der</font>(I[axis])/U.s = derI_IC[cartAxes[axis]];
        <font color="darkgreen">// Note:  initMethVel[cartAxes[axis]] == InitMethVelocity.None can&#39;t</font>
        <font color="darkgreen">// occur due to an assertion.</font>
      <font color="blue">end if</font>;
    <font color="blue">else</font>
      <font color="red">der</font>(M*phi[axis])/U.s = chemical.mPhidot[axis] + common.mechanical.mPhidot[
        axis] + inert.mPhidot[axis] + <font color="red">Delta</font>(faces[cartAxes[axis], :].p)*A[
        cartAxes[axis]] + Data.m*(phi_face_0[cartAxes[axis], :]*faces[cartAxes[
        axis], :].Ndot) + <font color="red">sum</font>(Data.m*(faces[<font color="red">cartWrap</font>(cartAxes[axis] -
        orientation), :].phi[orientation]*faces[<font color="red">cartWrap</font>(cartAxes[axis] -
        orientation), :].Ndot) + <font color="red">Sigma</font>(faces[<font color="red">cartWrap</font>(cartAxes[axis] -
        orientation), :].mPhidot[orientation]) <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation) +
        M*environment.a[cartAxes[axis]] + N*Data.z*environment.E[cartAxes[axis]]
        <font color="darkgreen">&quot;Conservation of linear momentum&quot;</font>;
      <font color="darkgreen">// **temp last terms</font>
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Thermal dynamics</font>
  <font color="blue">if </font>setTemp<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC for all time (energy not conserved).</font>
    <font color="blue">if </font>initMethTemp == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecific<font color="blue"> then</font>
      v = v_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecificRate<font color="blue"> then</font>
      <font color="red">der</font>(v)/U.s = derv_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      chemical.mu = mu_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(chemical.mu)/U.s = dermu_IC;
    <font color="blue">else</font>
      <font color="darkgreen">// if initMethTemp == InitMethScalar.ReactionRate then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Note:  initMethTemp == InitMethScalar.None can&#39;t occur due to an</font>
      <font color="darkgreen">// assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    (phi*<font color="red">der</font>(M*phi) + <font color="red">der</font>(N*h) - V*<font color="red">der</font>(p))/U.s = chemical.phi*chemical.mPhidot +
      chemical.mu*chemical.Ndot + chemical.Qdot + phi*common.mechanical.mPhidot +
      common.thermal.Qdot + inert.phi*inert.mPhidot + inert.Qdot + <font color="red">sum</font>(<font color="red">sum</font>((
      Data.m*(phi_face_0[axis, side]^2 + faces[axis, side].phi*faces[axis, side].phi)
       + <font color="red">Data.h</font>(faces[axis, side].T, faces[axis, side].p))*faces[axis, side].Ndot
      <font color="blue">for </font>side<font color="blue"> in </font>Side) <font color="blue">for </font>axis<font color="blue"> in </font>Axis) + <font color="red">sum</font>(<font color="red">sum</font>(faces.phi[orientation] .*
      faces.mPhidot[orientation]) <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation) + <font color="red">sum</font>(faces.Qdot)
      <font color="darkgreen">&quot;Energy conservation&quot;</font>;
    <font color="darkgreen">// **Update KE terms (LHS and RHS) to match dissertation.</font>
  <font color="blue">end if</font>;
  <font color="darkgreen">// **note in doc here or in characteristics: self diffusivity is a modified self diffusivity (2/2/13 notes)</font>
<font color="blue">end </font>Species;
</pre>
      </div>
    </div>
  </div>
</div>
<div class="footer">
  &copy; Copyright 2012, Kevin Davies, Georgia Tech Research Corporation. Last updated Fri Mar 22 21:01:17 2013.
</div>
</body>
</html>
