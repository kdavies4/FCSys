<html>
<head>
<title>FCSys.Subregions.Species</title>
<meta name="keywords" content="fuel cell library, FCSys, fuel cell, PEM, proton exchange membrane, polymer exchange membrance, PEMFC, Modelica, Dymola, electrochemistry">
<meta name="date" content="2013-1-29">
<meta name="description" content="Models for single-species storage, transport, and exchange of material, linear momentum, and energy">
<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="stylesheets/ModelicaDoc.css">
<link rel="shortcut icon" href="../resources/documentation/favicon.ico">
<script type="text/javascript" src="javascripts/analytics.js"></script>
</head>
<body>
<div class="sidebar">
  <div class="sidebarwrapper">
  <a href="index.html"><p class="sidebar-title">FCSys</p></a>
  <p class="logo"><a href="index.html">
    <img src="images/icon.gif" class="logo" alt="Logo" width=150>
  </a></p>

  <h3>Table of Contents</h3>
    <ul>
    <li><a href="FCSys_UsersGuide.html">User's Guide</a></li>
    <li><a href="FCSys_Blocks.html">Blocks</a></li>
    <li><a href="FCSys_Conditions.html">Conditions</a></li>
    <li><a href="FCSys_Assemblies.html">Assemblies</a></li>
    <li><a href="FCSys_Regions.html">Regions</a></li>
    <li><a href="FCSys_Subregions.html">Subregions</a></li>
    <li><a href="FCSys_Connectors.html">Connectors</a></li>
    <li><a href="FCSys_Characteristics.html">Characteristics</a></li>
    <li><a href="FCSys_Units.html">Units</a></li>
    <li><a href="FCSys_Quantities.html">Quantities</a></li>
    <li><a href="FCSys_BaseClasses.html">BaseClasses</a></li>
    </ul>

  <h3>Download</h3>
    <ul>
      <li>Latest: <a href="release/FCSys-2.0.zip" rel="nofollow">FCSys-2.0.zip</a> (**Please check back soon or contact kdavies4 at gmail.com.)</li>
    </ul>
  </div>
</div>

<div class="document">
  <div class="documentwrapper">
    <div class="bodywrapper">
      <div class="body">

<h2><a name="FCSys.Subregions.Species"></a><a href="FCSys_Subregions.html#FCSys.Subregions">FCSys.Subregions</a>.Species</h2>
<b>Models for single-species storage, transport, and exchange of material, linear momentum, and energy</b>
<p>
<p><h3>Information</h3></p>
Extends from <a href="http://build.openmodelica.org/Documentation/Modelica.Icons.Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).
<p><h3>Package Content</h3><p>
<table border=1 cellspacing=0 cellpadding=2 >
<tr><th>Name</th><th>Description</th></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'C+'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'C+'.html#FCSys.Subregions.Species.'C+'">'C+'</a>
</td><td>C</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'C19HF37O5S-'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'C19HF37O5S-'.html#FCSys.Subregions.Species.'C19HF37O5S-'">'C19HF37O5S-'</a>
</td><td>C<sub>19</sub>HF<sub>37</sub>O<sub>5</sub>S<sup>-</sup></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'e-'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'e-'.html#FCSys.Subregions.Species.'e-'">'e-'</a>
</td><td>e<sup>-</sup></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'H+'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'H+'.html#FCSys.Subregions.Species.'H+'">'H+'</a>
</td><td>H<sup>+</sup></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.H2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_H2.html#FCSys.Subregions.Species.H2">H2</a>
</td><td>H<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.H2O" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_H2O.html#FCSys.Subregions.Species.H2O">H2O</a>
</td><td>H<sub>2</sub>O</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.N2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_N2.html#FCSys.Subregions.Species.N2">N2</a>
</td><td>N<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.O2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_O2.html#FCSys.Subregions.Species.O2">O2</a>
</td><td>O<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.SpeciesSolid" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesSolid">SpeciesSolid</a>
</td><td>Solid species (inert and stagnant)</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.SpeciesIncompressible" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIncompressible">SpeciesIncompressible</a>
</td><td>Incompressible species</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.Species" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a>
</td><td>Model for single-species exchange, transport, and storage of material, linear momentum, and energy</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.BaseClassesS.png" alt="FCSys.Subregions.Species.BaseClasses" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses">BaseClasses</a>
</td><td>Base classes (not generally for direct use)</td></tr>
</table>
<hr>

<h2><img src="images/FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.SpeciesSolid" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.SpeciesSolid"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.SpeciesSolid</h2>
<b>Solid species (inert and stagnant)</b><p>
<img src="images/FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.SpeciesSolid">
<p><h3>Information</h3></p>
<p>Assumptions:<ol>
  <li>Zero dynamic compressibility (&rArr; uniform current)</li>
  <li>Zero dynamic fluidity (&rArr; no shearing)</li></ol>
  </p>

  <p>Usually, conditions should be applied to specify the velocity (typically <b>0</b>).  In a group of connected solid species
  of a single type (instances of a model derived from this one), there should be exactly one equation to specify the velocity along each Cartesian axis.
  For example, the x-axis velocity may be given by setting <code>setVelX</code> to <code>true</code> in one of the instances
  (x-axis velocity will be <code>phi_IC[Axis.x]</code> for all time).  Alternatively, one of the faces on the outside of the
  group could be removed by setting the appropriate <code>inclFaceNegX</code>, <code>inclFacePosX</code>, etc. parameter
  to <code>false</code>, which will set the current and transverse components of velocity to zero.</p>

  <p>For more information, see the <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model.</p><p>
Extends from <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIncompressible">SpeciesIncompressible</a> (Incompressible species).
<p><h3>Parameters</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>Lstar</td><td>&nbsp;</td><td>Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>) [l]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k[Axis]</td><td>{1,1,1}</td><td>Areal fill factor for transport (<b>k</b>) [1]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td><a href="FCSys_Characteristics_BaseClasses_Characteristic.html#FCSys.Characteristics.BaseClasses.Characteristic">Characteristic</a></td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CompressibilityDynamic">CompressibilityDynamic</a></td><td>Xi</td><td>0</td><td>Dynamic compressibility (&Xi;) [N.T/(l2.m)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.FluidityDynamic">FluidityDynamic</a></td><td>F</td><td>0</td><td>Dynamic fluidity [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>R</td><td>Data.R(T, p=p)</td><td>Thermal resistivity</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Boolean</td><td>inclLin[Axis]</td><td>{true,false,false}</td><td>true, if each component of linear momentum is included (<i>Do not adjust here.</i>)</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Prescribed states (via initialization parameters)</td></tr>
<tr><td>Boolean</td><td>setPartNum</td><td>false</td><td>Particle number</td></tr>
<tr><td>Boolean</td><td>setVelX</td><td>false</td><td>X-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelY</td><td>false</td><td>Y-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelZ</td><td>false</td><td>Z-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setTemp</td><td>false</td><td>Temperature</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>false</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>false</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>false</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Included faces</td></tr>
<tr><td>Boolean</td><td>inclFaceNegX</td><td>true</td><td>Negative X</td></tr>
<tr><td>Boolean</td><td>inclFacePosX</td><td>true</td><td>Positive X</td></tr>
<tr><td>Boolean</td><td>inclFaceNegY</td><td>true</td><td>Negative Y</td></tr>
<tr><td>Boolean</td><td>inclFacePosY</td><td>true</td><td>Positive Y</td></tr>
<tr><td>Boolean</td><td>inclFaceNegZ</td><td>true</td><td>Negative Z</td></tr>
<tr><td>Boolean</td><td>inclFacePosZ</td><td>true</td><td>Positive Z</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Scalar properties</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethPartNum</td><td>InitMethScalar.Volume</td><td>Method of initializing the particle number</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethTemp</td><td>InitMethScalar.Temperature</td><td>Method of initializing the temperature</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>derN_IC</td><td>0</td><td>Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">VolumeSpecific</a></td><td>v_IC</td><td>&nbsp;</td><td>Initial specific volume (<i>v</i><sub>IC</sub>) [l3/N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecificRate">VolumeSpecificRate</a></td><td>derv_IC</td><td>0</td><td>Initial rate of specific volume ((&part;<i>v</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/(N.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">VolumeRate</a></td><td>derV_IC</td><td>0</td><td>Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">PressureRate</a></td><td>derp_IC</td><td>0</td><td>Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>) [m/(l.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">TemperatureRate</a></td><td>derT_IC</td><td>0</td><td>Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>derh_IC</td><td>0</td><td>Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>mu_IC</td><td>&nbsp;</td><td>Initial electrochemical potential (&mu;<sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>dermu_IC</td><td>0</td><td>Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>Ndot_IC</td><td>0</td><td>Initial reaction rate (<i>N&#775;</i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Velocity</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethX</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the x-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethY</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the y-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethZ</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the z-axis component</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>zeros(3)</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
</table>
<p><h3>Connectors</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">ChemicalOutput</a></td><td>chemical</td><td>Connector to exchange material while advecting linear momentum and energy</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>common</td><td>Connector to directly couple velocities and temperatures of multiple species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inert</td><td>Connector to exchange linear momentum and heat by diffusion, with additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>xNegative</td><td>Negative face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>xPositive</td><td>Positive face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>yNegative</td><td>Negative face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>yPositive</td><td>Positive face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>zNegative</td><td>Negative face along the z axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>zPositive</td><td>Positive face along the z axis</td></tr>
</table>
<p><h3>Modelica definition</h3>
<pre>
<font color="blue">model</font> SpeciesSolid <font color="darkgreen">&quot;Solid species (inert and stagnant)&quot;</font>
  <font color="blue">extends </font><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIncompressible">SpeciesIncompressible</a>(
    <font color="blue">final </font>Xi=0,
    <font color="blue">final </font>F=0,
    <font color="blue">final </font>upstreamX=false,
    <font color="blue">final </font>upstreamY=false,
    <font color="blue">final </font>upstreamZ=false,
    <font color="blue">final </font>Ndot_IC=0,
    <font color="blue">final </font>phi_IC=<font color="red">zeros</font>(3),
    <font color="blue">final </font>derphi_IC,
    <font color="blue">final </font>I_IC,
    <font color="blue">final </font>derI_IC);
<textblock type="annotcomp" expanded="false">
<font color="blue">end </font>SpeciesSolid;
</pre>
<hr>

<h2><img src="images/FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.SpeciesIncompressible" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.SpeciesIncompressible"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.SpeciesIncompressible</h2>
<b>Incompressible species</b><p>
<img src="images/FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.SpeciesIncompressible">
<p><h3>Information</h3></p>

  <p>For more information, see the <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model.</p><p>
Extends from <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> (Model for single-species exchange, transport, and storage of material, linear momentum, and energy).
<p><h3>Parameters</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>Lstar</td><td>&nbsp;</td><td>Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>) [l]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k[Axis]</td><td>{1,1,1}</td><td>Areal fill factor for transport (<b>k</b>) [1]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td><a href="FCSys_Characteristics_BaseClasses_Characteristic.html#FCSys.Characteristics.BaseClasses.Characteristic">Characteristic</a></td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CompressibilityDynamic">CompressibilityDynamic</a></td><td>Xi</td><td>Data.Xi(T, v=v)</td><td>Dynamic compressibility (&Xi;) [N.T/(l2.m)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.FluidityDynamic">FluidityDynamic</a></td><td>F</td><td>Data.F(T)</td><td>Dynamic fluidity [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>R</td><td>Data.R(T, p=p)</td><td>Thermal resistivity</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Boolean</td><td>inclLin[Axis]</td><td>{true,false,false}</td><td>true, if each component of linear momentum is included (<i>Do not adjust here.</i>)</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Prescribed states (via initialization parameters)</td></tr>
<tr><td>Boolean</td><td>setPartNum</td><td>false</td><td>Particle number</td></tr>
<tr><td>Boolean</td><td>setVelX</td><td>false</td><td>X-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelY</td><td>false</td><td>Y-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelZ</td><td>false</td><td>Z-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setTemp</td><td>false</td><td>Temperature</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Included faces</td></tr>
<tr><td>Boolean</td><td>inclFaceNegX</td><td>true</td><td>Negative X</td></tr>
<tr><td>Boolean</td><td>inclFacePosX</td><td>true</td><td>Positive X</td></tr>
<tr><td>Boolean</td><td>inclFaceNegY</td><td>true</td><td>Negative Y</td></tr>
<tr><td>Boolean</td><td>inclFacePosY</td><td>true</td><td>Positive Y</td></tr>
<tr><td>Boolean</td><td>inclFaceNegZ</td><td>true</td><td>Negative Z</td></tr>
<tr><td>Boolean</td><td>inclFacePosZ</td><td>true</td><td>Positive Z</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Scalar properties</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethPartNum</td><td>InitMethScalar.Volume</td><td>Method of initializing the particle number</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethTemp</td><td>InitMethScalar.Temperature</td><td>Method of initializing the temperature</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>derN_IC</td><td>0</td><td>Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">VolumeSpecific</a></td><td>v_IC</td><td>&nbsp;</td><td>Initial specific volume (<i>v</i><sub>IC</sub>) [l3/N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecificRate">VolumeSpecificRate</a></td><td>derv_IC</td><td>0</td><td>Initial rate of specific volume ((&part;<i>v</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/(N.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">VolumeRate</a></td><td>derV_IC</td><td>0</td><td>Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">PressureRate</a></td><td>derp_IC</td><td>0</td><td>Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>) [m/(l.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">TemperatureRate</a></td><td>derT_IC</td><td>0</td><td>Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>derh_IC</td><td>0</td><td>Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>mu_IC</td><td>&nbsp;</td><td>Initial electrochemical potential (&mu;<sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>dermu_IC</td><td>0</td><td>Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>Ndot_IC</td><td>0</td><td>Initial reaction rate (<i>N&#775;</i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Velocity</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethX</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the x-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethY</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the y-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethZ</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the z-axis component</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>{0,0,0}</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Acceleration">Acceleration</a></td><td>derphi_IC[Axis]</td><td>{0,0,0}</td><td>Initial acceleration ((&part;<b>&phi;</b>/&part;<i>t</i>)<sub>IC</sub>) [l/T2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>I_IC[Axis]</td><td>{0,0,0}</td><td>Initial current (<i><b>I</b></i><sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CurrentRate">CurrentRate</a></td><td>derI_IC[Axis]</td><td>{0,0,0}</td><td>Initial rate of current ((&part;<i><b>I</b></i>/&part;<i>t</i>)<sub>IC</sub>) [N/T2]</td></tr>
</table>
<p><h3>Connectors</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">ChemicalOutput</a></td><td>chemical</td><td>Connector to exchange material while advecting linear momentum and energy</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>common</td><td>Connector to directly couple velocities and temperatures of multiple species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inert</td><td>Connector to exchange linear momentum and heat by diffusion, with additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>xNegative</td><td>Negative face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>xPositive</td><td>Positive face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>yNegative</td><td>Negative face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>yPositive</td><td>Positive face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>zNegative</td><td>Negative face along the z axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>zPositive</td><td>Positive face along the z axis</td></tr>
</table>
<p><h3>Modelica definition</h3>
<pre>
<font color="blue">model</font> SpeciesIncompressible <font color="darkgreen">&quot;Incompressible species&quot;</font>
  <font color="blue">extends </font><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a>(initMethPartNum=InitMethScalar.Volume);
  <font color="darkgreen">// Note:  The default, pressure, can&#39;t be used to initialize an incompressible</font>
  <font color="darkgreen">// species.</font>
<textblock type="annotcomp" expanded="false">
<font color="blue">end </font>SpeciesIncompressible;
</pre>
<hr>

<h2><img src="images/FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.Species" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.Species"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.Species</h2>
<b>Model for single-species exchange, transport, and storage of material, linear momentum, and energy</b><p>
<img src="images/FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.Species">
<p><h3>Information</h3></p>

    <p>This model is based on the following fixed assumptions.  Other assumptions are
    optional via the parameters.
    <ol>
       <li>All faces are rectangular.
       <li>The material is orthorhombic.  This implies that a
          gradient which induces diffusion along an axis does not induce
          diffusion along axes orthogonal to it
          [<a href="FCSys_UsersGuide.html#FCSys.UsersGuide.References">Bejan2006</a>,
          pp. 691&ndash;692].</li>
       <li>The coordinate system (x, y, z) is aligned with the principle
          axes of transport.  For example, if the species is stratified, the
          layers must be parallel to one of the planes in the rectilinear
          grid.</li>
       <li>The factors that may cause anisotropic behavior (<b><i>k</i></b>)
          are common to normal, transverse, and thermal transport.</li>
       <li>There are no body or inertial forces (e.g., gravity).</li>
    </ol>
    </p>

    <p>Figure 1 shows how instances of
    <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> models (derived from this
    model) are
    connected within a <a href="FCSys_Subregions.html#FCSys.Subregions">Subregion</a>.  The
    generalized resistances (<i>R</i>) affect the flow rates of linear momentum and
    heat associated with differences in velocity and temperature (respectively) between
    each species and a common node.  This exchange is diffusive.

    <p>Linear momentum and enthalpy are advected as material is exchanged in a chemical
    reaction.  This occurs at the velocity and massic enthalpy of the reactants (source
    species), where the reactant/product designation depends on the current conditions.
    If species are connected through
    a <a href="FCSys_Subregions.html#FCSys.Subregions.Reaction">Reaction</a> model, then the material
    states (e.g., amounts of each material) are directly coupled to impose chemical
    equilibrium.
    This reduces the DAE index by one in accordance with Gibbs' phase rule
    [<a href="FCSys_UsersGuide.html#FCSys.UsersGuide.References">Moran2004</a>].
    Resistance is not included directly in the reaction equations;
    the reaction rate is determined solely by
    the transport equations.</p>

    <p align=center><img src="images/exchange.png">
<br><b>Figure 1:</b>  Exchange of a quantity (linear momentum or heat) among species
    (A, B, and C) within a subregion.</p>

    <p>Figure 2 shows how <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a>
    instances of the same type are connected between neighboring
    <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a> instances.
    Normal and transverse linear momentum and heat are transported by both advection and diffusion.
    Upstream discretization is applied if it is enabled via the <code>upstreamX</code>,
    etc. parameters.</p>

    <p align=center><img src="images/transport.png">
<br><b>Figure 2:</b>  Transport of a quantity associated with the same species
    between subregions (1 and 2).</p>

    <p>All <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> instances
    within a <a href="FCSys_Subregions_Phases.html#FCSys.Subregions.Phases">Phase</a> are joined by Dalton's law (see the
    <a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a> connector), as shown
    in Figure 3a.  The pressures are additive, and each species is assumed to exist at the
    total extensive volume of the phase.  Within a <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a>,
    the <a href="FCSys_Subregions_Phases.html#FCSys.Subregions.Phases">Phases</a> are combined by Amagat's law (see the
    <a href="FCSys_Connectors.html#FCSys.Connectors.InertAmagat">InertAmagat</a> connector), as shown
    in Figure 3b.  The volumes are additive, and each species is assumed to exist at the
    total pressure in the subregion.</p>

    <table border=0 cellspacing=0 cellpadding=2 align=center class=noBorder style="margin-left: auto; margin-right: auto;">
      <tr align=center class=noBorder>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="images/share_pressure.png">
<br><b>a:</b>  Pressures of species (A, B, and C) are additive within a phase.
        </td>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="images/share_volume.png">
<br><b>b:</b>  Volumes of phases (I, II, and III) are additive within a subregion.
        </td>
      </tr>
      <tr align=center class=noBorder style="margin-left: auto; margin-right: auto;">
        <td colspan=2 align=center class=noBorder ><b>Figure 3:</b> Methods of attributing pressure and volume.</td>
      </tr>
    </table>

    <p> The following notes apply to the parameters:
    <ul>
    <li>Here (and in the rest of <a href="index.html#FCSys">FCSys</a>), the "specific"
    adjective means that the following extensive quantity is divided by particle number.
    ("Massic" indicates a quantity divided by mass.)</li>
    <li>In general, if dynamic compressibility, dynamic fluidity, or thermal resistivity is zero, then
    it should be set as <code>final</code> so that index reduction may be performed.
    If two <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> instances
    are connected through their <code>inert</code> connectors or faces (<code>xNegative</code>,
    <code>xPositive</code>, etc.) and both have zero generalized resistivities for a
    quantity, then index reduction is necessary.</li>
    <li>Even if an initialization parameter is not selected to be used explicitly,
    it may be used a guess value.</li>
    <li>The <b><i>k</i></b> factor can be used to account for the effects of porosity and tortousity
    on transport.
    It should be changed directly with effective area and inversely with effective length.
    The factor may reflect anisotropic properties; it is a vector with independent components
    for each axis. It affects all of the diffusive transport rates (normal, transverse, and
    thermal) by the same factor.  By default, its components are unity.</li>
    <li>By default, only the x-axis component of linear momentum is included.</li>
    <li>If a state is prescribed, then the
    associated initial condition (IC) will be applied for all time.  The
    corresponding conservation equation will not be imposed.
    If <code>setPartNum</code>, <code>setVelX</code>, <code>setVelY</code>, or <code>setVelZ</code> is
    <code>true</code>, then there may be a secondary effect on the energy conservation equation
    and thus temperature.
    In that case, it may be helpful to set <code>setTemp</code> to <code>true</code> so that
    the energy conservation equation is not imposed.</li>
    <li>If a subregion does not contain any compressible species, then pressure must be prescribed.
    Set <code>setPartNum</code> to <code>true</code> and <code>initMethPartNum</code>
    to <code>InitMethScalar.Pressure</code> for one of the species.</li>
    <li>The <code>start</code> values of the initial conditions for pressure and temperature
    (<i>p</i><sub>IC</sub> and <i>T</i><sub>IC</sub>) are the global default pressure and
    temperature (via the <code>outer</code> instance of the <a href="FCSys_Conditions.html#FCSys.Conditions.Environment">Environment</a> model).
    The <code>start</code> values of the initial conditions for
    other intensive properties (<i>v</i><sub>IC</sub>, <i>h</i><sub>IC</sub>, and
    &mu;<sub>IC</sub>) are related to the initial pressure and temperature
    by the characteristics of the species.  The <code>start</code> value of the
    initial condition for the extensive volume (<i>V</i><sub>IC</sub>) is the volume of the
    subregion, and the <code>start</code> value for particle number (<i>N</i><sub>IC</sub>)
    is related to it via the material characteristics (<code>Data</code>) and the initial pressure and temperature.
    In order to apply other values for any of these initial conditions,
    it may be necessary to do so before translating the model.</li>
    <li>A face connector may be removed by setting the corresponding <code>inclFaceNegX</code>,
    <code>inclFacePosX</code>, <code>inclFaceNegY</code>, etc. parameter to <code>false</code>.
    Then the boundary will be closed (zero current) and adiabatic with a no-slip condition
    (zero transverse velocity).</li>
    </p>

    <p>In evaluating the dynamics of a phase, it is typically assumed that all of the species
    exist at the same velocity and temperature.  The mechanical and thermal time constants
    are usually much shorter than the time span of interest due to the very small coupling
    resistances.  This assumption can be applied in the model by connecting the <code>common</code>
    connectors of the species, which will

    It will cause index reduction during translation.</p>

    <p>In the variables that relate to transport,
    the first index is the axis and the second index is the side.  The sides
    are ordered from negative to positive, according to the
    <a href="FCSys_BaseClasses.html#FCSys.BaseClasses.Side">Side</a> enumeration.
    Shear velocity and force are additionally indexed by
    the orientation of the momentum with respect to the face.
    The orientations are ordered in Cartesian space starting with the axis after the
    normal face, according to the
    <a href="FCSys_BaseClasses.html#FCSys.BaseClasses.Orientation">Orientation</a> enumeration.</p>
    <p>

<p><h3>Parameters</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>Lstar</td><td>&nbsp;</td><td>Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>) [l]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k[Axis]</td><td>{1,1,1}</td><td>Areal fill factor for transport (<b>k</b>) [1]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CompressibilityDynamic">CompressibilityDynamic</a></td><td>Xi</td><td>Data.Xi(T, v=v)</td><td>Dynamic compressibility (&Xi;) [N.T/(l2.m)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.FluidityDynamic">FluidityDynamic</a></td><td>F</td><td>Data.F(T)</td><td>Dynamic fluidity [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>R</td><td>Data.R(T, p=p)</td><td>Thermal resistivity</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Boolean</td><td>inclLin[Axis]</td><td>{true,false,false}</td><td>true, if each component of linear momentum is included (<i>Do not adjust here.</i>)</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Prescribed states (via initialization parameters)</td></tr>
<tr><td>Boolean</td><td>setPartNum</td><td>false</td><td>Particle number</td></tr>
<tr><td>Boolean</td><td>setVelX</td><td>false</td><td>X-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelY</td><td>false</td><td>Y-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelZ</td><td>false</td><td>Z-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setTemp</td><td>false</td><td>Temperature</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Included faces</td></tr>
<tr><td>Boolean</td><td>inclFaceNegX</td><td>true</td><td>Negative X</td></tr>
<tr><td>Boolean</td><td>inclFacePosX</td><td>true</td><td>Positive X</td></tr>
<tr><td>Boolean</td><td>inclFaceNegY</td><td>true</td><td>Negative Y</td></tr>
<tr><td>Boolean</td><td>inclFacePosY</td><td>true</td><td>Positive Y</td></tr>
<tr><td>Boolean</td><td>inclFaceNegZ</td><td>true</td><td>Negative Z</td></tr>
<tr><td>Boolean</td><td>inclFacePosZ</td><td>true</td><td>Positive Z</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Scalar properties</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethPartNum</td><td>InitMethScalar.Pressure</td><td>Method of initializing the particle number</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethTemp</td><td>InitMethScalar.Temperature</td><td>Method of initializing the temperature</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>derN_IC</td><td>0</td><td>Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">VolumeSpecific</a></td><td>v_IC</td><td>&nbsp;</td><td>Initial specific volume (<i>v</i><sub>IC</sub>) [l3/N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecificRate">VolumeSpecificRate</a></td><td>derv_IC</td><td>0</td><td>Initial rate of specific volume ((&part;<i>v</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/(N.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">VolumeRate</a></td><td>derV_IC</td><td>0</td><td>Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">PressureRate</a></td><td>derp_IC</td><td>0</td><td>Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>) [m/(l.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">TemperatureRate</a></td><td>derT_IC</td><td>0</td><td>Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>derh_IC</td><td>0</td><td>Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>mu_IC</td><td>&nbsp;</td><td>Initial electrochemical potential (&mu;<sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>dermu_IC</td><td>0</td><td>Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>Ndot_IC</td><td>0</td><td>Initial reaction rate (<i>N&#775;</i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Velocity</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethX</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the x-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethY</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the y-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethZ</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the z-axis component</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>{0,0,0}</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Acceleration">Acceleration</a></td><td>derphi_IC[Axis]</td><td>{0,0,0}</td><td>Initial acceleration ((&part;<b>&phi;</b>/&part;<i>t</i>)<sub>IC</sub>) [l/T2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>I_IC[Axis]</td><td>{0,0,0}</td><td>Initial current (<i><b>I</b></i><sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CurrentRate">CurrentRate</a></td><td>derI_IC[Axis]</td><td>{0,0,0}</td><td>Initial rate of current ((&part;<i><b>I</b></i>/&part;<i>t</i>)<sub>IC</sub>) [N/T2]</td></tr>
</table>
<p><h3>Connectors</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">ChemicalOutput</a></td><td>chemical</td><td>Connector to exchange material while advecting linear momentum and energy</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>common</td><td>Connector to directly couple velocities and temperatures of multiple species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inert</td><td>Connector to exchange linear momentum and heat by diffusion, with additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>xNegative</td><td>Negative face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>xPositive</td><td>Positive face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>yNegative</td><td>Negative face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>yPositive</td><td>Positive face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>zNegative</td><td>Negative face along the z axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>zPositive</td><td>Positive face along the z axis</td></tr>
</table>
<p><h3>Modelica definition</h3>
<pre>
<font color="blue">model</font> Species <font color="darkgreen">
  &quot;Model for single-species exchange, transport, and storage of material, linear momentum, and energy&quot;</font>
  <font color="blue">import </font><a href="http://build.openmodelica.org/Documentation/Modelica.Math.html#Modelica.Math.log10">Modelica.Math.log10</a>;
  <font color="darkgreen">//extends FCSys.BaseClasses.Icons.Names.Top1;</font>

  <font color="darkgreen">// Geometric parameters</font>
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> L[Axis](<font color="blue">each </font>min=Modelica.Constants.small) <font color="darkgreen">&quot;Length&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Area">Q.Area</a> A[Axis] <font color="darkgreen">&quot;Cross-sectional area&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> Lstar(
    min=Modelica.Constants.small,
    nominal=10*U.m,
    start=1e3*<font color="red">product</font>(L)^(1/3)) <font color="darkgreen">
    &quot;Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> k[Axis](
    <font color="blue">each </font>min=Modelica.Constants.small,
    <font color="blue">each </font><font color="blue">final </font>nominal=1) = {1,1,1} <font color="darkgreen">
    &quot;Areal fill factor for transport (<b>k</b>)&quot;</font>;

  <font color="darkgreen">// Material properties</font>
  <font color="blue">replaceable </font><font color="blue">package</font> Data = <a href="FCSys_Characteristics_BaseClasses_Characteristic.html#FCSys.Characteristics.BaseClasses.Characteristic">FCSys.Characteristics.BaseClasses.Characteristic</a> <font color="blue">
    constrainedby </font>FCSys.Characteristics.BaseClasses.Characteristic <font color="darkgreen">
    &quot;Characteristic data&quot;</font>;

  <font color="darkgreen">// Assumptions</font>
  <font color="darkgreen">// -----------</font>
  <font color="darkgreen">// General</font>
  <font color="blue">parameter </font>Boolean inclLin[Axis]={true,false,false} <font color="darkgreen">
    &quot;true, if each component of linear momentum is included (<i>Do not adjust here.</i>)&quot;</font>;
  <font color="darkgreen">// Even though this parameter is set as final within the constrainedby</font>
  <font color="darkgreen">// clauses of the models in the Phases package, Dymola 7.4 still shows</font>
  <font color="darkgreen">// it in the parameter dialog (hence the &quot;Do not adjust&quot;).</font>
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Dynamics</font>
  <font color="blue">parameter </font>Boolean setPartNum=false <font color="darkgreen">&quot;Particle number&quot;</font>;
  <font color="blue">parameter </font>Boolean setVelX=false <font color="darkgreen">&quot;X-axis component of velocity&quot;</font>;
  <font color="blue">parameter </font>Boolean setVelY=false <font color="darkgreen">&quot;Y-axis component of velocity&quot;</font>;
  <font color="blue">parameter </font>Boolean setVelZ=false <font color="darkgreen">&quot;Z-axis component of velocity&quot;</font>;
  <font color="blue">parameter </font>Boolean setTemp=false <font color="darkgreen">&quot;Temperature&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Upstream discretization</font>
  <font color="blue">parameter </font>Boolean upstreamX=true <font color="darkgreen">&quot;X&quot;</font>;
  <font color="blue">parameter </font>Boolean upstreamY=true <font color="darkgreen">&quot;Y&quot;</font>;
  <font color="blue">parameter </font>Boolean upstreamZ=true <font color="darkgreen">&quot;Z&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Included faces</font>
  <font color="blue">parameter </font>Boolean inclFaceNegX=true <font color="darkgreen">&quot;Negative X&quot;</font>;
  <font color="blue">parameter </font>Boolean inclFacePosX=true <font color="darkgreen">&quot;Positive X&quot;</font>;
  <font color="blue">parameter </font>Boolean inclFaceNegY=true <font color="darkgreen">&quot;Negative Y&quot;</font>;
  <font color="blue">parameter </font>Boolean inclFacePosY=true <font color="darkgreen">&quot;Positive Y&quot;</font>;
  <font color="blue">parameter </font>Boolean inclFaceNegZ=true <font color="darkgreen">&quot;Negative Z&quot;</font>;
  <font color="blue">parameter </font>Boolean inclFacePosZ=true <font color="darkgreen">&quot;Positive Z&quot;</font>;

  <font color="darkgreen">// Initialization parameters</font>
  <font color="darkgreen">// -------------------------</font>
  <font color="darkgreen">// Scalar properties</font>
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">BaseClasses.InitMethScalar</a> initMethPartNum=InitMethScalar.Pressure <font color="darkgreen">
    &quot;Method of initializing the particle number&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">BaseClasses.InitMethScalar</a> initMethTemp=InitMethScalar.Temperature <font color="darkgreen">
    &quot;Method of initializing the temperature&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N_IC(start=V_IC/v_IC) <font color="darkgreen">
    &quot;Initial particle number (<i>N</i><sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">// Note:  This parameter is left enabled even it isn&#39;t used to</font>
  <font color="darkgreen">// explicitly initialize any states, since it&#39;s used as a guess value.</font>
  <font color="darkgreen">// Similar notes apply to some other initial conditions below.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> derN_IC=0 <font color="darkgreen">
    &quot;Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">// Note:  Dymola 7.4 doesn&#39;t recognize enumerations in the dialog enable</font>
  <font color="darkgreen">// option, e.g.,</font>
  <font color="darkgreen">//     enable=initMethPartNum == InitMethScalar.AmountRate.</font>
  <font color="darkgreen">// Therefore, the values of the enumerations are specified numerically for</font>
  <font color="darkgreen">// this initial condition and some others below.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">Q.VolumeSpecific</a> v_IC(min=Modelica.Constants.small, start=<font color="red">Data.v_Tp</font>
        (T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial specific volume (<i>v</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecificRate">Q.VolumeSpecificRate</a> derv_IC=0 <font color="darkgreen">
    &quot;Initial rate of specific volume ((&part;<i>v</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V_IC(start=<font color="red">product</font>(L)) <font color="darkgreen">
    &quot;Initial volume (<i>V</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">Q.VolumeRate</a> derV_IC=0 <font color="darkgreen">
    &quot;Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p_IC(start=environment.p) <font color="darkgreen">
    &quot;Initial pressure (<i>p</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">Q.PressureRate</a> derp_IC=0 <font color="darkgreen">
    &quot;Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T_IC(nominal=298.15*U.K, start=environment.T)
    <font color="darkgreen">&quot;Initial temperature (<i>T</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">Q.TemperatureRate</a> derT_IC=0 <font color="darkgreen">
    &quot;Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h_IC(start=<font color="red">Data.h</font>(T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial specific enthalpy (<i>h</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">Q.PotentialRate</a> derh_IC=0 <font color="darkgreen">
    &quot;Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> mu_IC(start=<font color="red">Data.g</font>(T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial electrochemical potential (&mu;<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">Q.PotentialRate</a> dermu_IC=0 <font color="darkgreen">
    &quot;Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> Ndot_IC=0 <font color="darkgreen">
    &quot;Initial reaction rate (<i>N&#775;</i><sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Velocity</font>
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethX=InitMethVelocity.Velocity <font color="darkgreen">
    &quot;Method of initializing the x-axis component&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethY=InitMethVelocity.Velocity <font color="darkgreen">
    &quot;Method of initializing the y-axis component&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethZ=InitMethVelocity.Velocity <font color="darkgreen">
    &quot;Method of initializing the z-axis component&quot;</font>;
  <font color="darkgreen">// Note:  Dymola 7.4 doesn&#39;t provide pull-down lists for arrays of</font>
  <font color="darkgreen">// enumerations; therefore, a parameter is used for each axis.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial velocity (<b>&phi;</b><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Acceleration">Q.Acceleration</a> derphi_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial acceleration ((&part;<b>&phi;</b>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> I_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial current (<i><b>I</b></i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.CurrentRate">Q.CurrentRate</a> derI_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial rate of current ((&part;<i><b>I</b></i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;

  <font color="darkgreen">// Material properties</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.CompressibilityDynamic">Q.CompressibilityDynamic</a> Xi(nominal=1e8/(U.V*U.s)) = <font color="red">Data.Xi</font>(T, v=v) <font color="darkgreen">
    &quot;Dynamic compressibility (&Xi;)&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.FluidityDynamic">Q.FluidityDynamic</a> F(nominal=10*U.cm*U.s/U.g) = <font color="red">Data.F</font>(T) <font color="darkgreen">&quot;Dynamic fluidity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">Q.ResistivityThermal</a> R(nominal=10*U.cm/U.A) = <font color="red">Data.R</font>(T, p=p) <font color="darkgreen">
    &quot;Thermal resistivity&quot;</font>;

  <font color="darkgreen">// Preferred states</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N(
    nominal=4*U.C,
    <font color="blue">final </font>start=N_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Particle number&quot;</font>;
  <font color="darkgreen">// Note:  The start value for this variable (and others below) isn&#39;t fixed</font>
  <font color="darkgreen">// because the related initial condition is applied in the initial</font>
  <font color="darkgreen">// equation section.</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi[n_lin](
    <font color="blue">each </font>nominal=U.cm/U.s,
    <font color="blue">final </font>start=phi_IC[cartAxes],
    <font color="blue">each </font><font color="blue">final </font>fixed=false,
    <font color="blue">each </font>stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Velocity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T(
    nominal=298.15*U.K,
    <font color="blue">final </font>start=T_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Temperature&quot;</font>;

  <font color="darkgreen">// Aliases (for common terms)</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Mass">Q.Mass</a> M(
    nominal=1e-3*U.g,
    start=Data.m*N_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Mass&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V(
    nominal=U.cc,
    <font color="blue">final </font>start=V_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Volume&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p(
    nominal=U.atm,
    <font color="blue">final </font>start=p_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Pressure&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">Q.VolumeSpecific</a> v(
    nominal=U.cc/(4*U.C),
    <font color="blue">final </font>start=v_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Specific volume&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h(
    nominal=U.V,
    <font color="blue">final </font>start=h_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Specific enthalpy&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> I[n_lin](
    <font color="blue">each </font>nominal=U.A,
    <font color="blue">final </font>start=I_IC[cartAxes],
    <font color="blue">each </font><font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Current&quot;</font>;

  <font color="darkgreen">// Auxiliary variables (for analysis)</font>
  <font color="darkgreen">// ----------------------------------</font>
  <font color="darkgreen">// Misc. properties and conditions</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> mu(stateSelect=StateSelect.never) = T*chemical.muPerT <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Electrochemical potential&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> s(stateSelect=StateSelect.never) = h/T - chemical.muPerT
    <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Specific entropy&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> q[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = Data.m
    *phi .* I ./ (2*A[cartAxes]) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Dynamic pressure&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.CapacityThermalSpecific">Q.CapacityThermalSpecific</a> c_V(stateSelect=StateSelect.never) = <font color="red">
    Data.c_V</font>(T, p) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Isochoric specific heat capacity&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureReciprocal">Q.PressureReciprocal</a> beta_T(stateSelect=StateSelect.never) = <font color="red">
    Data.beta_T</font>(T, p) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Isothermal static compressibility&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Time constants</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_exch_mechanical(stateSelect=StateSelect.never) = alpha_F*N/
    Lstar <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Time constant for mechanical exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_exch_thermal(stateSelect=StateSelect.never) = alpha_R*N/
    Lstar <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Time constant for thermal exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_material(stateSelect=StateSelect.never) = <font color="red">noEvent</font>(<font color="blue">if </font>
    alpha_Xi &gt; Modelica.Constants.small<font color="blue"> then </font>Data.m*beta_T/alpha_Xi<font color="blue"> else </font>0) <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Time constant for material transport&quot;</font>;
  <font color="darkgreen">// Note that this isn&#39;t dependent on length or area---only intensive</font>
  <font color="darkgreen">// properties.</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_normal[Axis](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    fill</font>(alpha_Xi*N, 3) ./ Lstar_trans <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constants for normal mechanical transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_transverse[Axis](<font color="blue">each </font>stateSelect=StateSelect.never)
     = <font color="red">fill</font>(alpha_F*N, 3) ./ Lstar_trans <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constants for transverse mechanical transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_thermal[Axis](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    fill</font>(alpha_R*N, 3) ./ Lstar_trans <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constants for thermal transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> eta=<font color="red">log10</font>(<font color="red">max</font>({tau_exch_mechanical,tau_exch_thermal,<font color="red">
      max</font>([tau_trans_normal; tau_trans_transverse; tau_trans_thermal])})) - <font color="red">
      log10</font>(<font color="red">min</font>({tau_exch_mechanical,tau_exch_thermal,<font color="red">min</font>([tau_trans_normal;
      tau_trans_transverse; tau_trans_thermal])})) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Range of time constants in order of magnitude&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Peclet numbers (only for the axes with linear momentum included; others are</font>
  <font color="darkgreen">// zero)</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_0[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = I*alpha_Xi ./
    Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Normal Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_12[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = I*alpha_F ./
    Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Transverse Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_therm[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = I*
    alpha_R ./ Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Thermal Peclet numbers&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Bulk flow rates</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> mphiI[n_lin, Orientation](<font color="blue">each </font>stateSelect=StateSelect.never)
     = {(<font color="blue">if </font>inclLin[<font color="red">cartWrap</font>(cartAxes[axis] + orientation)]<font color="blue"> then </font>Data.m*phi[
    linAxes[<font color="red">cartWrap</font>(cartAxes[axis] + orientation)]]*I[axis]<font color="blue"> else </font>0) <font color="blue">for </font>
    orientation<font color="blue"> in </font>Orientation, axis<font color="blue"> in </font>1:n_lin} <font color="blue">if </font>n_lin &gt; 0<font color="blue"> and </font>environment.analysis
    <font color="darkgreen">&quot;Bulk rate of mechanical advection&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> TsI[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = T*s*I <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Bulk rate of thermal advection&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Linear momentum balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> Ma[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = M*(<font color="red">der</font>(phi)/U.s
     - environment.a[cartAxes]) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force relative to the frame of reference (constant mass)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_exch_adv[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) =
    chemical.mPhidot - Data.m*phi*chemical.Ndot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force due to advective exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_exch_diff[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) =
    common.mechanical.mPhidot + inert.mPhidot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Friction from other species (diffusive exchange)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_trans_adv[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = {Data.m
    *<font color="red">Delta</font>(v_face[cartAxes[axis], :] .* J_face[cartAxes[axis], :] .^ 2)*A[
    cartAxes[axis]] + <font color="red">sum</font>(Data.m*<font color="red">Delta</font>(phi_face[<font color="red">cartWrap</font>(cartAxes[axis] -
    orientation), :, orientation] .* J_face[<font color="red">cartWrap</font>(cartAxes[axis] -
    orientation), :])*A[<font color="red">cartWrap</font>(cartAxes[axis] - orientation)] <font color="blue">for </font>orientation<font color="blue">
     in </font>Orientation) <font color="blue">for </font>axis<font color="blue"> in </font>1:n_lin} <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force due to advective transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_trans_diff[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = {<font color="red">
    Sigma</font>(mPhidot_face_0[cartAxes[axis], :]) + <font color="red">sum</font>(<font color="red">Sigma</font>(mPhidot_face[<font color="red">cartWrap</font>(
    cartAxes[axis] - orientation), :, orientation]) <font color="blue">for </font>orientation<font color="blue"> in </font>
    Orientation) <font color="blue">for </font>axis<font color="blue"> in </font>1:n_lin} <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Friction from other subregions (diffusive transport; includes volume viscosity)&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Energy balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Ndere(stateSelect=StateSelect.never) = (N*(<font color="red">der</font>(h) + Data.m*<font color="red">der</font>
    (phi*phi)/2) - V*<font color="red">der</font>(p))/U.s <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of energy storage (internal and kinetic) at constant mass&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Wdot_exch(stateSelect=StateSelect.never) = -((Data.m*(chemical.hbar
     - phi*phi/2) - h)*chemical.Ndot + chemical.phi*chemical.mPhidot/2) <font color="blue">if </font>
    environment.analysis <font color="darkgreen">
    &quot;Relative rate of work (internal, flow, and kinetic) done by chemical exchange (advection)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_gen_exch(stateSelect=StateSelect.never) = phi*common.mechanical.mPhidot
     + inert.phi*inert.mPhidot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of heat generation due to friction with other species&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_exch(stateSelect=StateSelect.never) = common.thermal.Qdot +
    inert.Qdot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of thermal conduction from other species&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Wdot_trans(stateSelect=StateSelect.never) = -{<font color="red">sum</font>(<font color="red">inSign</font>(side)*
    (<font color="red">Data.h</font>(T_face[axis, side], p_face[axis, side]) + Data.m*((<font color="red">inSign</font>(side)*
    v_face[axis, side]*J_face[axis, side])^2 + phi_face[axis, side, :]*phi_face[
    axis, side, :])/2 - h - Data.m*phi*phi/2)*J_face[axis, side] <font color="blue">for </font>side<font color="blue"> in </font>
    Side) <font color="blue">for </font>axis<font color="blue"> in </font>Axis}*A <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Relative rate of work (internal, flow, and kinetic) done by advective transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_gen_trans(stateSelect=StateSelect.never) = <font color="red">sum</font>(phi_face .*
    mPhidot_face) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of heat generation due to friction with other subregions&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_trans(stateSelect=StateSelect.never) = <font color="red">sum</font>(Qdot_face) <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Rate of thermal conduction from other subregions&quot;</font>;
  <font color="darkgreen">// Note:  These auxiliary variables should not be used as states (hence</font>
  <font color="darkgreen">// StateSelect.never); the structure of the problem should not change if</font>
  <font color="darkgreen">// they are included.</font>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">FCSys.Connectors.ChemicalOutput</a> chemical(
    <font color="blue">final </font>n_lin=n_lin,
    <font color="blue">final </font>m=Data.m,
    <font color="blue">final </font>formula=Data.formula,
    muPerT(<font color="blue">final </font>start=mu_IC/T_IC,<font color="blue">final </font>fixed=false),
    phi(<font color="blue">final </font>start=phi_IC[cartAxes]),
    Ndot(<font color="blue">final </font>start=Ndot_IC,<font color="blue">final </font>fixed=false),
    hbar(<font color="blue">final </font>start=<font color="red">Data.h</font>(T_IC, p_IC)/Data.m)) <font color="darkgreen">
    &quot;Connector to exchange material while advecting linear momentum and energy&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Inert">FCSys.Connectors.Inert</a> common(
    <font color="blue">final </font>n_lin=n_lin,
    mechanical(phi(<font color="blue">final </font>start=phi_IC[cartAxes], <font color="blue">each </font><font color="blue">final </font>fixed=false)),
    thermal(T(<font color="blue">final </font>start=T_IC,<font color="blue">final </font>fixed=false))) <font color="darkgreen">
    &quot;Connector to directly couple velocities and temperatures of multiple species&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">FCSys.Connectors.InertDalton</a> inert(
    <font color="blue">final </font>n_lin=n_lin,
    V(
      min=0,
      <font color="blue">final </font>start=V_IC,
      <font color="blue">final </font>fixed=false),
    p(<font color="blue">final </font>start=p_IC, <font color="blue">final </font>fixed=false),
    phi(start=phi_IC[cartAxes]),
    T(start=T_IC)) <font color="darkgreen">
    &quot;Connector to exchange linear momentum and heat by diffusion, with additivity of pressure&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Face">FCSys.Connectors.Face</a> xNegative(
    <font color="blue">final </font>J(start=I_IC[Axis.x]/A[Axis.x]) = J_face[Axis.x, Side.n],
    <font color="blue">final </font>mPhidot_0(start=p_IC*A[Axis.x]) = mPhidot_face_0[Axis.x, Side.n],
    <font color="blue">final </font>phi(start=phi_IC[{Axis.y,Axis.z}]) = phi_face[Axis.x, Side.n, :],
    <font color="blue">final </font>mPhidot=mPhidot_face[Axis.x, Side.n, :],
    <font color="blue">final </font>T(start=T_IC) = T_face[Axis.x, Side.n],
    <font color="blue">final </font>Qdot(start=0) = Qdot_face[Axis.x, Side.n]) <font color="blue">if </font>inclFaceNegX <font color="darkgreen">
    &quot;Negative face along the x axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.Face">FCSys.Connectors.Face</a> xPositive(
    <font color="blue">final </font>J(start=I_IC[Axis.x]/A[Axis.x]) = J_face[Axis.x, Side.p],
    <font color="blue">final </font>mPhidot_0(start=-p_IC*A[Axis.x]) = mPhidot_face_0[Axis.x, Side.p],
    <font color="blue">final </font>phi(start=phi_IC[{Axis.y,Axis.z}]) = phi_face[Axis.x, Side.p, :],
    <font color="blue">final </font>mPhidot=mPhidot_face[Axis.x, Side.p, :],
    <font color="blue">final </font>T(start=T_IC) = T_face[Axis.x, Side.p],
    <font color="blue">final </font>Qdot(start=0) = Qdot_face[Axis.x, Side.p]) <font color="blue">if </font>inclFacePosX <font color="darkgreen">
    &quot;Positive face along the x axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.Face">FCSys.Connectors.Face</a> yNegative(
    <font color="blue">final </font>J(start=I_IC[Axis.y]/A[Axis.y]) = J_face[Axis.y, Side.n],
    <font color="blue">final </font>mPhidot_0(start=p_IC*A[Axis.y]) = mPhidot_face_0[Axis.y, Side.n],
    <font color="blue">final </font>phi(start=phi_IC[{Axis.z,Axis.x}]) = phi_face[Axis.y, Side.n, :],
    <font color="blue">final </font>mPhidot=mPhidot_face[Axis.y, Side.n, :],
    <font color="blue">final </font>T(start=T_IC) = T_face[Axis.y, Side.n],
    <font color="blue">final </font>Qdot(start=0) = Qdot_face[Axis.y, Side.n]) <font color="blue">if </font>inclFaceNegY <font color="darkgreen">
    &quot;Negative face along the y axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.Face">FCSys.Connectors.Face</a> yPositive(
    <font color="blue">final </font>J(start=I_IC[Axis.y]/A[Axis.y]) = J_face[Axis.y, Side.p],
    <font color="blue">final </font>mPhidot_0(start=-p_IC*A[Axis.y]) = mPhidot_face_0[Axis.y, Side.p],
    <font color="blue">final </font>phi(start=phi_IC[{Axis.z,Axis.x}]) = phi_face[Axis.y, Side.p, :],
    <font color="blue">final </font>mPhidot=mPhidot_face[Axis.y, Side.p, :],
    <font color="blue">final </font>T(start=T_IC) = T_face[Axis.y, Side.p],
    <font color="blue">final </font>Qdot(start=0) = Qdot_face[Axis.y, Side.p]) <font color="blue">if </font>inclFacePosY <font color="darkgreen">
    &quot;Positive face along the y axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.Face">FCSys.Connectors.Face</a> zNegative(
    <font color="blue">final </font>J(start=I_IC[Axis.z]/A[Axis.z]) = J_face[Axis.z, Side.n],
    <font color="blue">final </font>mPhidot_0(start=p_IC*A[Axis.z]) = mPhidot_face_0[Axis.z, Side.n],
    <font color="blue">final </font>phi(start=phi_IC[{Axis.x,Axis.y}]) = phi_face[Axis.z, Side.n, :],
    <font color="blue">final </font>mPhidot=mPhidot_face[Axis.z, Side.n, :],
    <font color="blue">final </font>T(start=T_IC) = T_face[Axis.z, Side.n],
    <font color="blue">final </font>Qdot(start=0) = Qdot_face[Axis.z, Side.n]) <font color="blue">if </font>inclFaceNegZ <font color="darkgreen">
    &quot;Negative face along the z axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.Face">FCSys.Connectors.Face</a> zPositive(
    <font color="blue">final </font>J(start=I_IC[Axis.z]/A[Axis.z]) = J_face[Axis.z, Side.p],
    <font color="blue">final </font>mPhidot_0(start=-p_IC*A[Axis.z]) = mPhidot_face_0[Axis.z, Side.p],
    <font color="blue">final </font>phi(start=phi_IC[{Axis.x,Axis.y}]) = phi_face[Axis.z, Side.p, :],
    <font color="blue">final </font>mPhidot=mPhidot_face[Axis.z, Side.p, :],
    <font color="blue">final </font>T(start=T_IC) = T_face[Axis.z, Side.p],
    <font color="blue">final </font>Qdot(start=0) = Qdot_face[Axis.z, Side.p]) <font color="blue">if </font>inclFacePosZ <font color="darkgreen">
    &quot;Positive face along the z axis&quot;</font>;</textblock>

  <font color="darkgreen">// Geometric parameters</font>

<font color="blue">protected </font>
  <font color="blue">final </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> Lstar_trans[Axis]=k .* A ./ L <font color="darkgreen">
    &quot;Effective cross-sectional area per length&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Integer n_lin=<font color="red">countTrue</font>(inclLin) <font color="darkgreen">
    &quot;Number of components of linear momentum&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Integer cartAxes[n_lin]=<font color="red">index</font>(inclLin) <font color="darkgreen">
    &quot;Cartesian-axis indices of the axes of linear momentum&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Integer linAxes[Axis]=<font color="red">enumerate</font>(inclLin) <font color="darkgreen">
    &quot;Linear momentum component indices of the Cartesian axes&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Boolean upstream[Axis]={upstreamX,upstreamY,upstreamZ} <font color="darkgreen">
    &quot;true, if each Cartesian axis uses upstream discretization&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Boolean setVel[Axis]={setVelX,setVelY,setVelZ} <font color="darkgreen">
    &quot;true, if each component of linear momentum is prescribed&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethVel[Axis]={initMethX,
      initMethY,initMethZ} <font color="darkgreen">&quot;Initialization methods for velocity&quot;</font>;

  <font color="darkgreen">// Base resistivity factors</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> alpha_Xi(nominal=5*U.cm/U.A) = Xi*Data.m*v/2 <font color="darkgreen">
    &quot;Base resistivity factor for dynamic compressibility&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> alpha_F(nominal=5*U.cm/U.A) = F*Data.m/2 <font color="darkgreen">
    &quot;Base resistivity factor for dynamic fluidity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> alpha_R(nominal=5*U.cm/U.A) = R*<font color="red">Data.c_V</font>(T, p)/2 <font color="darkgreen">
    &quot;Base resistivity factor for thermal resistivity&quot;</font>;

  <font color="darkgreen">// Efforts and flows of the conditional connectors</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.CurrentAreic">Q.CurrentAreic</a> J_face[Axis, Side](<font color="blue">each </font>nominal=U.A,start=<font color="red">transpose</font>(<font color="red">fill</font>(I_IC ./
        A, 2))) <font color="darkgreen">&quot;Areic currents at the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> mPhidot_face_0[Axis, Side](<font color="blue">each </font>nominal=U.atm*U.cm^2,start=<font color="red">
        outerProduct</font>(p_IC*A, {1,-1})) <font color="darkgreen">&quot;Forces on the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Pressure">Q.Pressure</a> p_face[Axis, Side](<font color="blue">each </font>nominal=U.atm,start=<font color="red">fill</font>(
        p_IC,
        3,
        2)) <font color="darkgreen">&quot;Pressures at the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">Q.VolumeSpecific</a> v_face[Axis, Side](<font color="blue">each </font>nominal=U.cc/(4*U.C),start=<font color="red">fill</font>(
        v_IC,
        3,
        2)) <font color="darkgreen">&quot;Specific volumes at the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_face[Axis, Side, Orientation](<font color="blue">each </font>nominal=U.cm/U.s,start={{{<font color="blue">
        if </font>inclLin[<font color="red">cartWrap</font>(axis + orientation)]<font color="blue"> then </font>phi_IC[<font color="red">cartWrap</font>(axis +
        orientation)]<font color="blue"> else </font>0 <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation} <font color="blue">for </font>side<font color="blue"> in </font>Side} <font color="blue">
        for </font>axis<font color="blue"> in </font>Axis}) <font color="darkgreen">&quot;Shear velocities at the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> mPhidot_face[Axis, Side, Orientation](<font color="blue">each </font>nominal=U.N,start={<font color="red">fill</font>({
        phi_IC[<font color="red">cartWrap</font>(axis + orientation)] <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation}, 2)
        <font color="blue">for </font>axis<font color="blue"> in </font>Axis}) <font color="darkgreen">&quot;Shear forces on the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T_face[Axis, Side](<font color="blue">each </font>start=T_IC) <font color="darkgreen">
    &quot;Temperatures at the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_face[Axis, Side] <font color="darkgreen">&quot;Heat flow rates into the faces&quot;</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">outer </font><a href="FCSys_Conditions.html#FCSys.Conditions.Environment">FCSys.Conditions.Environment</a> environment <font color="darkgreen">&quot;Environmental conditions&quot;</font>;</textblock>
  <font color="darkgreen">// Note:  In Dymola 7.4 it&#39;s necessary to add the missing inner message</font>
  <font color="darkgreen">// here to give a warning message, even though it&#39;s included in the</font>
  <font color="darkgreen">// Environment model too.</font>

<font color="blue">initial </font><font color="blue">equation </font>
  <font color="darkgreen">// Check that the initialization methods are valid.</font>
  <font color="red">assert</font>(initMethPartNum &lt;&gt; initMethTemp<font color="blue"> or </font>initMethPartNum == InitMethScalar.None,
    &quot;The initialization methods for particle number and temperature cannot be the same (unless None).&quot;);
  <font color="blue">if </font><font color="blue">not </font>Data.isCompressible<font color="blue"> then</font>
    <font color="red">assert</font>(initMethPartNum &lt;&gt; InitMethScalar.Pressure<font color="blue"> and </font>initMethPartNum &lt;&gt;
      InitMethScalar.PressureRate<font color="blue"> or </font>setPartNum, &quot;The material is incompressible,
      yet the initialization method for particle number involves pressure.&quot;);
    <font color="red">assert</font>(initMethTemp &lt;&gt; InitMethScalar.Pressure<font color="blue"> and </font>initMethTemp &lt;&gt;
      InitMethScalar.PressureRate<font color="blue"> or </font>setTemp, &quot;The material is incompressible,
      yet the initialization method for temperature involves pressure.&quot;);
    <font color="blue">if </font><font color="blue">not </font>Data.hasThermalExpansion<font color="blue"> then</font>
      <font color="red">assert</font>(initMethPartNum &lt;&gt; InitMethScalar.VolumeSpecific<font color="blue"> and </font>
        initMethPartNum &lt;&gt; InitMethScalar.VolumeSpecificRate<font color="blue"> or </font>setPartNum, &quot;The material is isochoric,
      yet the initialization method for particle number involves specific volume.&quot;);
      <font color="red">assert</font>(initMethTemp &lt;&gt; InitMethScalar.VolumeSpecific<font color="blue"> and </font>initMethTemp &lt;&gt;
        InitMethScalar.VolumeSpecificRate<font color="blue"> or </font>setPartNum, &quot;The material is isochoric,
      yet the initialization method for temperature involves specific volume.&quot;);
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">/* This is commented out because it may be annoying.
  // Warn when index reduction may be necessary.
  if abs(Xi) &lt; Modelica.Constants.small then
    Modelica.Utilities.Streams.print(&quot;Warning: The dynamic compressibility is zero.
    This may directly couple the densities within neighboring subregions.
Consider setting the value of Xi as final (if not already) so that index reduction may be performed.&quot;);
  end if;
  if abs(F) &lt; Modelica.Constants.small then
    Modelica.Utilities.Streams.print(&quot;Warning: The dynamic fluidity is zero.
    This may directly couple the velocity of this species with others within the subregion or with the same species within neighboring subregions.
Consider setting the value of F as final (if not already) so that index reduction may be performed.&quot;);
  end if;
  if abs(R) &lt; Modelica.Constants.small then
    Modelica.Utilities.Streams.print(&quot;Warning: The thermal resistivity is zero.
    This may directly couple the temperature of this species with others within the subregion or with the same species within neighboring subregions.
Consider setting the value of R as final (if not already) so that index reduction may be performed.&quot;);
  end if;
  // Note:  According to the Modelica specification (&gt;=3.0), these
  // checks should be possible using the assert() command with
  // level=AssertionLevel.warning.  However, this isn&#39;t supported in
  // Dymola 7.4 or FD2012.
  */</font>

  <font color="darkgreen">// Particle number</font>
  <font color="blue">if </font>setPartNum<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected, since the state is prescribed.</font>
    <font color="red">assert</font>(initMethPartNum &lt;&gt; InitMethScalar.None, &quot;The state for particle number is prescribed,
yet its condition is not defined.
Choose a condition besides None.&quot;);
  <font color="blue">else</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initMethPartNum == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecific<font color="blue"> then</font>
      v = v_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecificRate<font color="blue"> then</font>
      <font color="red">der</font>(v)/U.s = derv_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      T*chemical.muPerT = mu_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(T*chemical.muPerT)/U.s = dermu_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.ReactionRate<font color="blue"> then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Else, initMethPartNum == InitMethScalar.None; then, there are no</font>
      <font color="darkgreen">// initial equations.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Velocity</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>Axis<font color="blue"> loop</font>
    <font color="blue">if </font>inclLin[axis]<font color="blue"> then</font>
      <font color="blue">if </font>setVel[axis]<font color="blue"> then</font>
        <font color="darkgreen">// Ensure that a condition is selected, since the state is</font>
        <font color="darkgreen">// prescribed.</font>
        <font color="red">assert</font>(initMethVel[axis] &lt;&gt; InitMethVelocity.None, &quot;The state for the &quot; +
          {&quot;x&quot;,&quot;y&quot;,&quot;z&quot;}[axis] + &quot;-axis component of linear momentum is prescribed,
yet its condition is not defined.
Choose any condition besides None.&quot;);
      <font color="blue">else</font>
        <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
        <font color="blue">if </font>initMethVel[axis] == InitMethVelocity.Velocity<font color="blue"> then</font>
          phi[linAxes[axis]] = phi_IC[axis];
        <font color="blue">elseif </font>initMethVel[axis] == InitMethVelocity.Acceleration<font color="blue"> then</font>
          <font color="red">der</font>(phi[linAxes[axis]])/U.s = derphi_IC[axis];
        <font color="blue">elseif </font>initMethX == InitMethVelocity.Current<font color="blue"> then</font>
          I[linAxes[axis]] = I_IC[axis];
        <font color="blue">elseif </font>initMethVel[axis] == InitMethVelocity.CurrentRate<font color="blue"> then</font>
          <font color="red">der</font>(I[linAxes[axis]])/U.s = derI_IC[axis];
          <font color="darkgreen">// Else, initMethVel[axis] == InitMethVelocity.None; then, there are</font>
          <font color="darkgreen">// no initial equations.</font>
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Temperature</font>
  <font color="blue">if </font>setTemp<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected, since the state is prescribed.</font>
    <font color="red">assert</font>(initMethTemp &lt;&gt; InitMethScalar.None, &quot;The state for temperature is prescribed,
yet its condition is not defined.
Choose a condition besides None.&quot;);
  <font color="blue">else</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initMethTemp == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecific<font color="blue"> then</font>
      v = v_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecificRate<font color="blue"> then</font>
      <font color="red">der</font>(v)/U.s = derv_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      T*chemical.muPerT = mu_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(T*chemical.muPerT)/U.s = dermu_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.ReactionRate<font color="blue"> then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Else, initMethTemp == InitMethScalar.None; then, there are no</font>
      <font color="darkgreen">// initial equations.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

<font color="blue">equation </font>
  <font color="darkgreen">// Aliases (only for clarity)</font>
  p = inert.p;
  V = inert.V;
  v*N = V;
  T = common.thermal.T;
  phi = common.mechanical.phi;
  N*phi = L[cartAxes] .* I;
  M = Data.m*N;
  p_face = {{<font color="red">inSign</font>(side)*mPhidot_face_0[axis, side] <font color="blue">for </font>side<font color="blue"> in </font>Side}/A[axis] <font color="blue">
    for </font>axis<font color="blue"> in </font>Axis};

  <font color="darkgreen">// Thermodynamic correlations</font>
  <font color="blue">if </font>Data.isCompressible<font color="blue"> then</font>
    p = <font color="red">Data.p_Tv</font>(T, V/N);
  <font color="blue">else</font>
    V = N*<font color="red">Data.v_Tp</font>(T, p);
  <font color="blue">end if</font>;
  h = <font color="red">Data.h</font>(T, p);
  h = T*(chemical.muPerT + <font color="red">Data.s</font>(T, p));
  v_face = {<font color="red">Data.v_Tp</font>(T_face[axis, :], p_face[axis, :]) <font color="blue">for </font>axis<font color="blue"> in </font>Axis};

  <font color="darkgreen">// Exchange</font>
  <font color="darkgreen">// --------</font>
  <font color="darkgreen">// Material</font>
  chemical.mPhidot = <font color="red">semiLinear</font>(
    Data.m*chemical.Ndot,
    chemical.phi,
    phi) <font color="darkgreen">&quot;Advection&quot;</font>;
  F*inert.mPhidot = 2*Lstar*(inert.phi - phi) <font color="darkgreen">&quot;Diffusion&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Fluid/thermal</font>
  chemical.Hdot = <font color="red">semiLinear</font>(
    chemical.Ndot,
    chemical.hbar*Data.m,
    h) <font color="darkgreen">&quot;Advection&quot;</font>;
  R*inert.Qdot = 2*Lstar*(inert.T - T) <font color="darkgreen">&quot;Diffusion&quot;</font>;

  <font color="darkgreen">// Transport</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>Axis<font color="blue"> loop</font>
    <font color="blue">for </font>side<font color="blue"> in </font>Side<font color="blue"> loop</font>
      <font color="darkgreen">// Normal</font>
      Xi*(mPhidot_face_0[axis, side] - <font color="red">inSign</font>(side)*p*A[axis]) = Lstar_trans[
        axis]*(J_face[axis, side] - (<font color="blue">if </font>inclLin[axis]<font color="blue"> then </font>I[linAxes[axis]]/A[
        axis]<font color="blue"> else </font>0))*(<font color="blue">if </font>upstream[axis]<font color="blue"> and </font>inclLin[axis]<font color="blue"> then </font><font color="red">exp</font>(<font color="red">inSign</font>(
        side)*I[linAxes[axis]]*alpha_Xi/Lstar_trans[axis]) + 1<font color="blue"> else </font>2);

      <font color="darkgreen">// Transverse</font>
      <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation<font color="blue"> loop</font>
        F*mPhidot_face[axis, side, orientation] = Lstar_trans[axis]*(phi_face[
          axis, side, orientation] - (<font color="blue">if </font>inclLin[<font color="red">cartWrap</font>(axis + orientation)]<font color="blue">
           then </font>phi[linAxes[<font color="red">cartWrap</font>(axis + orientation)]]<font color="blue"> else </font>0))*(<font color="blue">if </font>
          upstream[axis]<font color="blue"> and </font>inclLin[axis]<font color="blue"> then </font><font color="red">exp</font>(<font color="red">inSign</font>(side)*I[linAxes[axis]]
          *alpha_F/Lstar_trans[axis]) + 1<font color="blue"> else </font>2);
      <font color="blue">end for</font>;

      <font color="darkgreen">// Thermal</font>
      R*Qdot_face[axis, side] = Lstar_trans[axis]*(T_face[axis, side] - T)*(<font color="blue">if </font>
        upstream[axis]<font color="blue"> and </font>inclLin[axis]<font color="blue"> then </font><font color="red">exp</font>(<font color="red">inSign</font>(side)*I[linAxes[axis]]*
        alpha_R/Lstar_trans[axis]) + 1<font color="blue"> else </font>2);

      <font color="darkgreen">// Apply Conditions if the connectors are removed.</font>
      <font color="blue">if </font><font color="blue">not </font>[inclFaceNegX, inclFacePosX; inclFaceNegY, inclFacePosY;
          inclFaceNegZ, inclFacePosZ][axis, side]<font color="blue"> then</font>
        J_face[axis, side] = 0 <font color="darkgreen">&quot;Closed&quot;</font>;
        phi_face[axis, side, :] = {0,0} <font color="darkgreen">&quot;No slip&quot;</font>;
        Qdot_face[axis, side] = 0 <font color="darkgreen">&quot;Adiabatic&quot;</font>;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Material dynamics</font>
  <font color="blue">if </font>setPartNum<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC for all time (material not conserved).</font>
    <font color="blue">if </font>initMethPartNum == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecific<font color="blue"> then</font>
      v = v_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecificRate<font color="blue"> then</font>
      <font color="red">der</font>(v)/U.s = derv_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      T*chemical.muPerT = mu_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(T*chemical.muPerT)/U.s = dermu_IC;
    <font color="blue">else</font>
      <font color="darkgreen">//if initMethPartNum == InitMethScalar.ReactionRate then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Note:  initMethPartNum == InitMethScalar.None can&#39;t occur due to an</font>
      <font color="darkgreen">// assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    <font color="red">der</font>(N)/U.s = chemical.Ndot + A*<font color="red">Delta</font>(J_face) <font color="darkgreen">&quot;Material conservation&quot;</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Mechanical dynamics</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>1:n_lin<font color="blue"> loop</font>
    <font color="blue">if </font>setVel[cartAxes[axis]]<font color="blue"> then</font>
      <font color="darkgreen">// Apply the IC for all time (linear momentum isn&#39;t conserved along</font>
      <font color="darkgreen">// this axis).</font>
      <font color="blue">if </font>initMethVel[cartAxes[axis]] == InitMethVelocity.Velocity<font color="blue"> then</font>
        phi[axis] = phi_IC[cartAxes[axis]];
      <font color="blue">elseif </font>initMethVel[cartAxes[axis]] == InitMethVelocity.Acceleration<font color="blue"> then</font>
        <font color="red">der</font>(phi[axis])/U.s = derphi_IC[cartAxes[axis]];
      <font color="blue">elseif </font>initMethX == InitMethVelocity.Current<font color="blue"> then</font>
        I[axis] = I_IC[cartAxes[axis]];
      <font color="blue">elseif </font>initMethVel[cartAxes[axis]] == InitMethVelocity.CurrentRate<font color="blue"> then</font>
        <font color="red">der</font>(I[axis])/U.s = derI_IC[cartAxes[axis]];
        <font color="darkgreen">// Note:  initMethVel[cartAxes[axis]] == InitMethVelocity.None can&#39;t</font>
        <font color="darkgreen">// occur due to an assertion.</font>
      <font color="blue">end if</font>;
    <font color="blue">else</font>
      <font color="red">der</font>(M*phi[axis])/U.s = chemical.mPhidot[axis] + common.mechanical.mPhidot[
        axis] + inert.mPhidot[axis] + A[cartAxes[axis]]*<font color="red">Sigma</font>(mPhidot_face_0[
        cartAxes[axis], :]) + Data.m*<font color="red">Delta</font>(v_face[cartAxes[axis], :] .* J_face[
        cartAxes[axis], :] .^ 2)*A[cartAxes[axis]] + <font color="red">sum</font>(Data.m*<font color="red">Delta</font>(phi_face[<font color="red">
        cartWrap</font>(cartAxes[axis] - orientation), :, orientation] .* J_face[<font color="red">
        cartWrap</font>(cartAxes[axis] - orientation), :]*A[<font color="red">cartWrap</font>(cartAxes[axis] -
        orientation)]) + <font color="red">Sigma</font>(mPhidot_face[<font color="red">cartWrap</font>(cartAxes[axis] -
        orientation), :, orientation]) <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation) + M*
        environment.a[cartAxes[axis]] <font color="darkgreen">&quot;Conservation of linear momentum&quot;</font>;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Thermal dynamics</font>
  <font color="blue">if </font>setTemp<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC for all time (energy not conserved).</font>
    <font color="blue">if </font>initMethTemp == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecific<font color="blue"> then</font>
      v = v_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeSpecificRate<font color="blue"> then</font>
      <font color="red">der</font>(v)/U.s = derv_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      T*chemical.muPerT = mu_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(T*chemical.muPerT)/U.s = dermu_IC;
    <font color="blue">else</font>
      <font color="darkgreen">//if initMethTemp == InitMethScalar.ReactionRate then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Note:  initMethTemp == InitMethScalar.None can&#39;t occur due to an</font>
      <font color="darkgreen">// assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    (<font color="red">der</font>(N*h) + <font color="red">der</font>(M*phi*phi)/2 - V*<font color="red">der</font>(p))/U.s = chemical.phi*chemical.mPhidot
      /2 + Data.m*chemical.hbar*chemical.Ndot + phi*common.mechanical.mPhidot +
      common.thermal.Qdot + inert.phi*inert.mPhidot + inert.Qdot + {<font color="red">sum</font>(<font color="red">inSign</font>(
      side)*(<font color="red">Data.h</font>(T_face[axis, side], p_face[axis, side]) + Data.m*((v_face[
      axis, side]*J_face[axis, side])^2 + phi_face[axis, side, :]*phi_face[axis,
      side, :])/2)*J_face[axis, side] <font color="blue">for </font>side<font color="blue"> in </font>Side) <font color="blue">for </font>axis<font color="blue"> in </font>Axis}*A + <font color="red">
      sum</font>(phi_face .* mPhidot_face) + <font color="red">sum</font>(Qdot_face) <font color="darkgreen">&quot;Energy conservation&quot;</font>;
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>Species;
</pre>
      </div>
    </div>
  </div>
</div>
<div class="footer">
  &copy; Copyright 2012, Kevin Davies, Georgia Tech Research Corporation. Last updated Tue Jan 29 17:51:15 2013.
</div>
</body>
</html>
